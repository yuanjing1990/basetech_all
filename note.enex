<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-export SYSTEM "http://xml.evernote.com/pub/evernote-export2.dtd">
<en-export export-date="20140417T080845Z" application="Evernote/Windows" version="5.x">
<note><title>HTTP://220.249.88.172/dws</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><a href="HTTP://220.249.88.172/dws">HTTP://220.249.88.172/dws</a></div></en-note>]]></content><created>20130607T095249Z</created><tag>日志外网IP</tag><note-attributes><latitude>30.47530000000000</latitude><longitude>114.40500000000000</longitude><altitude>0.00000000000000</altitude><source>mobile.android</source></note-attributes></note><note><title>睡前絮语</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>本来想直接写成qq日志的，但发现手机qq没这个功能，所以暂时写到印象笔记中吧！<br/>10:40，今天睡的有点早，就躺床上写些胡思乱想的东西吧！过去的一年已经养成了晚睡的习惯，经常都是凌晨睡觉，因为害怕躺下后胡思乱想，害怕在寂静的黑暗中咀嚼生活的苦楚。思考总是让人痛苦，所以我选择了逃避，我会一个人玩游戏到凌晨，我会看第二次网络小说，我会开着灯躺在床上看着白色的天花板放空，而唯独不会在黑暗中让情感发酵。其实我很迷茫，也很焦虑，我不知道生活的目标是什么，我也害怕生活会摆一道我解不出来的难题。喜欢回忆过去的人，是因为他现在过得不好。我现在总是喜欢回忆过去，大学，高中，初中甚至小学，我回忆并不是为了纪念，而是在想我当然为什么要这样或那样，那个在时间车轮下的我获得了什么丢失了什么。人总是喜欢把一生分为一个一个阶段，我们在一个阶段完结时会总结并对下一个阶段期许，可我们是否会想到人生的乐曲会在某个调上戛然而止？今年二姨去世了，最后一次见到她是在侄子的满月宴上，当时还笑着问我有女朋友没！人生难测，只珍朝夕。<br/></div></en-note>]]></content><created>20130112T155931Z</created><tag>瞎扯</tag><note-attributes><latitude>30.49850000000000</latitude><longitude>113.87000000000000</longitude><altitude>0.00000000000000</altitude><source>mobile.android</source></note-attributes></note><note><title>eng</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>in this chapter,we review some of the foundamentals introduced in the first part of this book in depth,the declaration of templates,the restrictions on template parameters,the constriants on template arguments,and so forth.<br/> </div></en-note>]]></content><created>20120927T023250Z</created><updated>20120927T023521Z</updated><tag>English</tag><note-attributes><latitude>30.47470000000000</latitude><longitude>114.40400000000000</longitude><altitude>0.00000000000000</altitude><source>mobile.android</source></note-attributes></note><note><title>笔记 @ 武汉市, 湖北省</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>这一张文凭，仿佛有亚当夏娃身下那一片树叶的功用，可以遮羞包丑。小小一片纸片能把一个人的空疏，寡陋，愚笨都掩盖起来。<br/>好像一切没恋爱的男人，方鸿渐把爱字看得太尊贵和严重，不肯轻易应用在女人身上。<br/>女人不傻决不因男人的浪费摆阔而对他有好印象——可是你放心，女人全是傻得，恰似男人所希望的那样傻，不多不少。<br/>一切长辈都不愿小辈瞒着自己有秘密；把这些秘密哄出来，逼出来，是长辈应尽的责任。<br/> </div></en-note>]]></content><created>20130904T042222Z</created><updated>20130906T091847Z</updated><tag>文摘</tag><tag>围城</tag><note-attributes><latitude>30.46970000000000</latitude><longitude>114.40000000000001</longitude><altitude>0.00000000000000</altitude><source>mobile.android</source></note-attributes></note><note><title>Song</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
A place nearby ---lene marlin
<div>Rolling in the deep ---Adele</div><div>Girl on the fire ---Alicia Keys</div></en-note>]]></content><created>20131001T134615Z</created><updated>20131001T135912Z</updated><tag>好听的歌</tag></note><note><title>MFC基础</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">MFC基础</span></div><div><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;"><br/></span></div><div><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">MFC</span><span style="font-size: 10.5pt;">以微软基类库，是针对</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">Windows</span><span style="font-size: 10.5pt;">平台界面程序的一个框架，其封装了</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WIN32</span><span style="font-size: 10.5pt;">编程的方方面面，简化了开发人员对</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WIN32</span><span style="font-size: 10.5pt;">程序的开发。</span></div><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">MFC</span><span style="font-size: 10.5pt;">封装的类都派生于</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">CObject</span><span style="font-size: 10.5pt;">，</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">CObject</span><span style="font-size: 10.5pt;">产生了一个用</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">6</span><span style="font-size: 10.5pt;">个宏来定义，分别赋予了其动态类型识别，动态类型创建以及序列化的功能。</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">//</span><span style="font-size: 10.5pt;">动态类型识别的能力</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">&nbsp;class</span><span lang="EN-US" style="font-size: 10.5pt;">name::GetRuntimeClass()</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">DECLARE_DYNAMIC(classname)</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">IMPLEMENT_DYNAMIC(classname,baseclassname)</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">&nbsp;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">//</span><span style="font-size: 10.5pt;">动态类型创建的能力</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">&nbsp;C</span><span lang="EN-US" style="font-size: 10.5pt;">RuntimeClass::CreateObject()</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">DECLARE_DYCREATE(classname)</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">IMPLEMENT_DYNAMIC(classname,baseclassname)</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">&nbsp;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">//序列化的能力，即存储读取的能力（Searilize())</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">DECLARE_SERIAL(classname)</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">IMPLEMENT_DYNAMIC(classname,baseclassname)</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">&nbsp;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">CCmdTarget</span><span style="font-size: 10.5pt;">类派生自</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">CObject</span><span style="font-size: 10.5pt;">类，并且有接收和处理来自应用程序菜单或工具栏的命令消息的能力，同样派生于它的类也具有了这样的能力。</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp;</span></p><div><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">CWnd</span><span style="font-size: 10.5pt;">类派生自</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">CCmdTarget</span><span style="font-size: 10.5pt;">类，封装了</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">Window API</span><span style="font-size: 10.5pt;">中关于窗口创建的功能，派生自它的类可以创新出窗口并显示。</span></div><div><span style="font-size: 10.5pt;"><br/></span></div><div><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">根据上面讲的基类，<span lang="EN-US">MFC</span>的主要类的层次结构为：</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">Cobject</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">|-CCmdTarget</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; |-CWinThread</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; | |-CWinApp</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; |</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; |-CWnd</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; | |-CFrameWnd</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; | |-Cview</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; | |-CDialog</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; |</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; |-CDocument</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; |</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; |-CDocTemplate</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; &nbsp; |-CSingleDocTemplate</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp; &nbsp; |-CMultiDocTemplate</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">&nbsp;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">消息分为</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">3</span><span style="font-size: 10.5pt;">种：窗口消息，命令消息和控件通知</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">消息可以被发送和寄送，消息通过窗口的处理程序进行</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">发送的消息会立刻调用窗口处理程序，调用函数阻塞等待处理返回</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">寄送的消息是被放入消息队列中排队等候窗口处理程序处理，调用程序直接返回</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">鼠标键盘消息是寄送的，而其他所有消息通常是发送的</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WIN32</span><span style="font-size: 10.5pt;">消息的结构：</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">typedef</span><span lang="EN-US" style="font-size: 10.5pt;">&nbsp;struct tagMSG{</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin-right: 0cm; margin-left: 27pt; margin-bottom: 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">HWND hWnd;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin-right: 0cm; margin-left: 27pt; margin-bottom: 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">UINT message;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin-right: 0cm; margin-left: 27pt; margin-bottom: 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WPARAM wParam;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin-right: 0cm; margin-left: 27pt; margin-bottom: 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">LPARAM lParam;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin-right: 0cm; margin-left: 27pt; margin-bottom: 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">DWORD time;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin-right: 0cm; margin-left: 27pt; margin-bottom: 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">POINT pt;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">}MSG;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">&nbsp;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">窗口消息是与窗口自身相关的一些消息：如</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WM_CREATE</span><span style="font-size: 10.5pt;">，</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WM_PAINT</span><span style="font-size: 10.5pt;">，</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WM_MOUSEMOVE</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">格式为</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">message</span><span lang="EN-US" style="font-size: 10.5pt;">(WM_XXX) wParam(</span><span style="font-size: 10.5pt;">命令参数）<span lang="EN-US">&nbsp;lParam(</span>命令参数<span lang="EN-US">)</span></span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">命令消息是菜单和工具栏消息，为</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WM_COMMAND</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">格式为</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">message</span><span lang="EN-US" style="font-size: 10.5pt;">(WM_COMMAND) wParam(0,COMMAND ID) lParam(0)</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">控件消息是控件窗口发送给父窗口的消息</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">(</span><span style="font-size: 10.5pt;">控件消息只能发送？</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">)</span><span style="font-size: 10.5pt;">：可能是</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WM_XXX</span><span style="font-size: 10.5pt;">，</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WM_COMMAND,WM_NOTIFY</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span style="font-size: 10.5pt;">格式有</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">3</span><span style="font-size: 10.5pt;">种，分别是：</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">mess</span><span lang="EN-US" style="font-size: 10.5pt;">age(WM_XXX)&nbsp;</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">wParam(</span><span style="font-size: 10.5pt;">命令参数</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">) lParam</span><span lang="EN-US" style="font-size: 10.5pt;">(</span><span style="font-size: 10.5pt;">命令参数<span lang="EN-US">) WM_PARENTNOTIFY,WM_CTLCOLOR,WM_DRAWITEM,</span></span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">WM_MEASUREITEM,WM_DELETEITEM,WM_CHARTOITEM,WM_VKEYTOITEM,WM_COMPAREITEM,WM_HSCROLL,WM_VSCROLL</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">message(WM_COMMAND) wParam(XN_XXX,</span><span style="font-size: 10.5pt;">控件</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">ID) lParam(</span><span style="font-size: 10.5pt;">控件窗口句柄</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">) XN_XXX</span><span style="font-size: 10.5pt;">因控件不同而不同，如</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">EN_CHANGE</span><span style="font-size: 10.5pt;">表示编辑框中的内容发生变化</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">message(WM_NOTIFY) wParam(</span><span style="font-size: 10.5pt;">控件</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">ID) lParam(</span><span style="font-size: 10.5pt;">指向</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">NMHDR</span><span style="font-size: 10.5pt;">的指针</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">)</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">typedef struct tagNMHDR{</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin-right: 0cm; margin-left: 27pt; margin-bottom: 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">HWND hwndFrom;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin-right: 0cm; margin-left: 27pt; margin-bottom: 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">UINT idFrom;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin-right: 0cm; margin-left: 27pt; margin-bottom: 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">UINT code;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">}NMHDR;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">&nbsp;</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">CWinApp</span><span style="font-size: 10.5pt;">对象在</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">Run()</span><span style="font-size: 10.5pt;">函数中接收消息，调用</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">PreTranslateMessage</span><span lang="EN-US" style="font-size: 10.5pt;">(),TranslateMessage()</span><span style="font-size: 10.5pt;">翻译快捷键和把原始键码转换成键字符，之后调用</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">DispatchMessage()</span><span style="font-size: 10.5pt;">分派消息到相应的</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">CWnd</span><span style="font-size: 10.5pt;">对象让与其对应的消息响应函数处理消息</span></p><p style="line-height: 23px; font-family: &apos;lucida Grande&apos;, Verdana; font-size: 14px; background-color: rgb(255, 255, 255); margin: 0cm 0cm 0.0001pt;"><span lang="EN-US" style="font-size: 10.5pt;">&nbsp;</span></p><div><span style="font-size: 10.5pt;">在</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">MFC</span><span style="font-size: 10.5pt;">中只要对象直接或间接派生于</span><span lang="EN-US" style="font-size: 10.5pt; font-family: Calibri, sans-serif;">CCmdTarget</span><span style="font-size: 10.5pt;">，定义了消息处理函数，并且定义一个查找表，这样这个类的实例就可以处理定义在消息查找表中的消息</span></div></div><div><span style="font-size: 10.5pt;"><br/></span></div><div><span style="font-size: 10.5pt;"><br/></span></div><div><span style="font-size: 10.5pt;"><br/></span></div></en-note>]]></content><created>20131010T124018Z</created><updated>20131030T015036Z</updated><tag>学习</tag><tag>MFC</tag></note><note><title>总结</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd"><en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>明天就是除夕了，今天中午就到家了，虽然路上有点郁闷，但是到家见到爸妈还是很高兴的。<br/>转眼一年又过了，回家感觉变化不大，而实际上我们又长了一岁，爸妈头上又多了几缕白发，脸上又多了几条皱纹。随着年龄的增长，总会生出许多<br/>要考虑的问题，不能再像以前一样逃避，默默的被生活打磨，渐渐的成长成熟。<br/>毕业后的第二个春节，感觉越来越冷清了。又工作了一年，感触也颇多！工作并不是说有专业能力就可以了，更需要的是有很强交际能力，有专业能力也许可以做好工作，但是领导在升职时首先想到的却不会是你！我以前总是觉得知足常乐，何必为那些没有的去烦恼忧愁，总是装x的觉得不强求是一种境界，总是在一些烦闷的时候念叨菩提本无树，总觉得我可以不受其他人的影响保持自己的本心，现在我只想说去tmd，在这个只向钱看的社会，还tmd装什么清高，还谈什么理想！怎么有点愤青的感觉~_~，说好的社会主义好青年呢！<br/> 看到了刚毕业的新同事来公司，看他们就看到去年的自己！看着他们我也看到了我自己的改变，愿意或者不愿意，我们总要根据周围的环境而改变！</div></en-note>]]></content><created>20130208T072433Z</created><updated>20130209T114407Z</updated><tag>瞎扯</tag><note-attributes><latitude>30.49850000000000</latitude><longitude>113.87000000000000</longitude><altitude>0.00000000000000</altitude><source>mobile.android</source></note-attributes></note><note><title>Boost库any的设计</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><p><code><a href="file:///D:/Boost/boost_1_41_0_doc_20091225/boost_doc/doc/html/boost/any.html" title="Class any">any</a></code> 中所使用的值类型value type有以下特定要求：</p><div><ul compact="compact" type="disc"><li><em>ValueType</em> 必须是 <em>CopyConstructible</em> [20.1.3]的。</li><li><em>ValueType</em> 不一定要是 <em>Assignable</em> [23.1]的。但要求所有形式的赋值都要保证是强异常安全的。</li><li><em>ValueType</em> 的析构函数要满足不抛出异常的安全保证。</li></ul>
&nbsp;支持任意值类型间的复制，以及带严格类型安全检查的值读取。</div><div><br/></div><div>any源码分析</div><div><a href="http://blog.csdn.net/pongba/article/details/82811">http://blog.csdn.net/pongba/article/details/82811</a></div><div><br/></div><div><p align="center" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center"><strong><span lang="EN-US" style="FONT-SIZE: 16pt; FONT-FAMILY: Verdana">boost</span></strong><strong><span style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana">源码剖析之：泛型指针类</span></strong><strong><span lang="EN-US" style="FONT-SIZE: 16pt; FONT-FAMILY: Verdana">any</span></strong><strong><span style="FONT-SIZE: 16pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana">之海纳百川</span></strong><strong><span lang="EN-US" style="FONT-SIZE: 16pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体">(rev#2)</span></strong></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana">&nbsp;</span></p><p align="center" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">刘未鹏</span></p><p align="center" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana">C++</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">的罗浮宫</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana">(http://blog.csdn.net/pongba)</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><strong><span style="FONT-SIZE: 14pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana">动机</span></strong></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">C++</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">是强类型语言，所有强类型语言对类型的要求都是苛刻的，类型一有不合编译器就会抱怨说不能将某某类型转换为某某类型，当然如果在类型之间提供了转换操作符或是标准所允许的一定程度的隐式转换</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">(</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">如经过非</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">explicit</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">构造函数创建临时变量的隐式转换或是在</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">long</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">这些基本类型间的</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">)</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">又另当别论。总的说来，为了保持类型安全，</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">C++</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">有严厉的要求。然而有时候程序员可能有这样的需要</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">:</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int i;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">iong j;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">X x; //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">假设</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">X</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">为用户定义的类</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any anyVal=i;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">... //use anyVal as a int value</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">anyVal=j;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">... //use anyVal as a long value</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">anyVal=x;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">... //use anyVal as a long value</span></p></div><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">考虑这样的一个</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">“</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">泛型指针类</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">”</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">该如何设计是很有趣的事情。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">1.</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">它本身不能是模板类，因为如果它是模板，你必须为它的具现化提供模板参数。而事实上你并不想这样做。你想<em>让</em><strong>同一个对象</strong><em>接受任意类型的数据</em>。在上面的代码中这个对象是</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">anyVal</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">。然而，如果你必须为它提供模板参数，那么上面的代码看起来就会像这样：</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any&lt;int&gt; anyIntVal=i;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any&lt;long&gt; anyLongVal=j;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">...</span></p></div><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">这显然已经丧失了</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">anyVal</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的优势</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">——</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">以单个对象接受所有类型的数据。与其这样还不如直接写</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">:</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int anyIntVal=i;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int anyLongVal=j;</span></p></div><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">所以，</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">不能是模板类。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">2.</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">它必须提供某些有关它所保存的对象类型的信息。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">3.</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">它必须提供某种方法将它保存的数值</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">“</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">取出来</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">”</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">事实上，</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">boost</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">库已经提供了这样的类</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">boost::any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，下面我就为你讲述它的原理及构造。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><strong><span lang="EN-US" style="FONT-SIZE: 14pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">boost::any</span></strong><strong><span style="FONT-SIZE: 14pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">原理与结构</span></strong></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">首先，</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">类里面一定要<strong>提供一个模板构造函数和模板</strong></span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">operator=</span></strong><strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">操作符</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">。因为你必须允许用户写出：</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any any_value(val); //val</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的类型为任意的</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any_value=val1; //val1</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">类型也是任意的</span></p></div><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">这样的代码。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">其次，数据的存放之所是个问题，显然你不能将它保存在</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">类中，那会导致</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">类成为模板类，后者是明确不被允许的。数据应该动态存放，即动态分配一个数据的容器来存放数据，而</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">类中则保存指向这个容器的指针，明确地说，是<strong>指向这个容器的基类</strong>的指针，这是因为容器本身必须为模板，而</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">类中的指针成员又必须不是泛型的</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">(</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">因为</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">不能是泛型的，所以</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">中所有数据成员都不能是泛型的</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">)</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，所以，结论是：<strong>为容器准备一个非泛型的基类，而让指针指向该基类</strong>。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">下面就看一看</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">boost</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">库是如何具体实现这两点的。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">摘自</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">”boost/any.hpp”</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">class any</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">public:</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">class <strong>placeholder</strong> //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">泛型数据容器</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">holder</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的非泛型基类</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">public:</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">//</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">虚析构函数，为保证派生类对象能用基类指针析构</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual ~placeholder(){}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">public:</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp; //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">提供关于类型的信息</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual const std::type_info &amp; type() const = 0;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual placeholder * clone() const = 0;&nbsp; //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">复制</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}; // <strong>placeholder</strong></span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">template&lt;typename ValueType&gt;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">class <strong>holder</strong> : public <strong>placeholder</strong></span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">public:</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">holder(const ValueType &amp; value)</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">: held(value)</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">public:</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual const std::type_info &amp; type() const</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp; // typeid</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">返回</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">std::typeinfo</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">对象引用，后者包含任意对象的类型信息，</span> <span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">如</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">name</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，此外还提供</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">operator==</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">操作符你可以用</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">typeid(oneObj)==typeid(anotherObj)</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">来比两个对象之类型是否一致。</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">return typeid(ValueType);&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual placeholder * clone() const</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">return new holder(held);&nbsp; //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">改写虚函数，返回自身的复制体</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">public:</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">ValueType held; //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">数据保存的地方</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}; <strong>// holder</strong></span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">//</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">指向泛型数据容器</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">holder</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的基类</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">placeholder</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的指针</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">placeholder * content;</span></strong></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">//</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">模板构造函数，动态分配数据容器并调用其构造函数</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">template&lt;typename ValueType&gt;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any(const ValueType &amp; value)</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">: content(new holder&lt;ValueType&gt;(value))</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">...</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">//</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">与模板构造函数一样，但使用了</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">swap</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">惯用手法</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">template&lt;typename ValueType&gt;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any &amp; operator=(const ValueType &amp; rhs)</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">//</span> <span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">先创建一个临时对象</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any(rhs)</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，再调用下面的</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">swap</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">函数进行底层数据交换，注意与</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">*this</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">交换数据的是临时对象，所以</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">rhs</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的底层数据并未被更改，只是在</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">swap</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">结束后临时对象拥有了</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">*this</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的底层数据，而此时</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">*this</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">也拥有了临时对象构造时所拥有的</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">rhs</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的数据的副本。然后临时对象由于生命期的结束而被自动析构，</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">*this</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">原来的底层数据随之烟消云散。</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any(rhs).swap(*this);</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">return *this;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any &amp; swap(any &amp; rhs) //swap</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">函数，交换底层数据</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">std::swap(content, rhs.content); //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">只是简单地将两个指针的值互换</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">return *this;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">~any()&nbsp; //</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">析构函数</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp; //</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">释放容器，用的是基类指针，这就是</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">placeholder</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">需要一个虚析构函数的原因</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">delete content;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">...</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">};</span></p></div><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">这虽然并非</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的全部源代码，但是所有重要的思想已经表露无遗。剩下的部分只是一些简单的细节，请参见</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">boost</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">库的原文件。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">“</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">但是等等！</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">”</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，你急切的说：</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">“</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">你失去了类型的信息。</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">”</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">唔</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">...</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的确，当赋值的模板函数返回后你也就失去了关于类型的信息。考虑下面你可能想要写出的代码：</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int i=10;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">boost::any anyVal=i;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int j=anyVal;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">// error</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，实际上你是想把</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">anyVal</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">赋给另一个</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">型变量，这应该以某种方式被允许，但决不是在</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">类中提供转换操作符，因为你事先并不知道要用</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">anyVal</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">来承载何种类型的变量，所以转换操作符无从给出。</span></p></div><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">当转换操作符的设想彻底失败后，我们只能借助于某些</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">“</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">外来</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">”</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的显式转换操作。就向</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">static_cast&lt;&gt;</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">一样。</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">boost</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">提供了</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any_cast&lt;&gt;</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，于是你可以这样写：</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int j=any_cast&lt;int&gt;(anyVal);</span></p></div><p style="MARGIN: 0cm 0cm 0pt"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana">事实上，</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana">any_cast</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana">的代码是这样的：</span></p><p style="MARGIN: 0cm 0cm 0pt"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">template&lt;typename ValueType&gt;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">ValueType any_cast(const any &amp; operand)</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp; //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">调用</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any_cast</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">针对指针的版本。</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">const ValueType * result = <strong>any_cast</strong>&lt;ValueType&gt;(<strong>&amp;</strong>operand);</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">//</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">如果</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">cast</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">失败，即实际</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">保存的并非</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">ValueType</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">型数据，则抛出一个异常。</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">if(!result)</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">throw bad_any_cast(); //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">派生自</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">std::bad_cast</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">return *result;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}</span></p></div><p style="MARGIN: 0cm 0cm 0pt"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana">而</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana">any_cast</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana">针对指针的版本是这样：</span></p><p style="MARGIN: 0cm 0cm 0pt"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">template&lt;typename ValueType&gt;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">ValueType * any_cast(any * operand)</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp; //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">这个类型检查很重要，后面会对它作更详细的解释</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">return</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">operand &amp;&amp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">(<strong>operand-&gt;type()==typeid(ValueType)</strong>) <strong>?</strong> // <strong>#1</strong></span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&amp;<strong>static_cast</strong>&lt;any::holder&lt;ValueType&gt;*&gt;(operand-&gt;content)-&gt;held</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12.05pt; background-position: initial initial; background-repeat: initial initial;"><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">:</span></strong> <span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">0; //</span> <span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">这儿有个向下类型转换</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p></div><p style="MARGIN: 0cm 0cm 0pt"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana">这两个</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana">any_cast</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana">版本应该很好理解。此外后一个版本中</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体">#1</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana">处的类型检查也是必要的，如果没有这个检查，考虑以下代码：</span></p><p style="MARGIN: 0cm 0cm 0pt"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int i=10;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">boost::any anyVal=i;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">//</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">如果没有那个类型检查，这将通过编译且运行期通常也不会出错，但是对</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">d</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的赋值将会是非常奇怪的情形。</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">double d=any_cast&lt;double&gt;(anyVal);</span></p></div><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">这将通过编译，且运行期<strong>通常</strong>竟然也不会出错，下面我为你解释为什么会这样。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">boost::anyVal=i;</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">其实将</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">anyVal.content</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">指针指向了一个</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">holder&lt;int&gt;</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">对象</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">(</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">请回顾上面的代码</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">)</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">。然后</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any_cast&lt;double&gt;(anyVal)</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">实际上调用了</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any_cast&lt;&gt;</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">针对指针的重载版本，并将</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">anyVal</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的地址传递过去，也就是转到</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">#1</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">处，因为调用的是</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any_cast&lt;double&gt;</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，所以</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">#1</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">处的代码被编译器实例化为：</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">// <strong>#2</strong></span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">static_cast&lt;<strong>any::holder&lt;double&gt; *</strong>&gt;(operand-&gt;content)-&gt;held</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">但是前面说过，</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">operand-&gt;content</span><strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">实际</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">指向的是</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">any::holder&lt;int&gt;</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">，所以这个</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">static_cast</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">是</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">“</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">非法</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">”</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的，然而事实是：它能通过编译！原因很简单：</span> <strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;"><span lang="EN-US">holder&lt;double&gt;</span></span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">是</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">placeholder</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的派生类，而</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">operand-&gt;content</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的类型正是</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">placeholder</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">。从基类指针到派生类指针的转换被认为是合法的。但这却酿成大错，因为<strong>表达式</strong></span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">#2</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的类型将因此被推导为</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">double</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">！原先</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">holder&lt;int&gt;</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">只给</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int held;</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">成员分配了</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">sizeof(int)</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">个字节的内存，而现在却要将</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">型的</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">held</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">当作</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">double</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">型来使用，也就是说使用</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">sizeof(double)</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">个字节内存。所以这就相当于：</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">int i=10;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">double* pd=(double*)(void*)&amp;i;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">//</span> <span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">行为未定义，但通常却不会出错，然而隐藏的错误更可怕，你得到的</span><span lang="EN-US" style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">d</span><span style="FONT-SIZE: 12pt; COLOR: #ff6600; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-hansi-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的值几乎肯定不是你想要的。</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">double d=*pd;</span></p></div><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">使用</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">typeinfo</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">让我们有可能在<strong>运行时</strong>发现这种类型不符并及时抛出异常。但有个违反直观的事情是上面的那行错误的代码仍能通过编译，并且你也无法阻止它通过编译，因为</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">holder&lt;int&gt;</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">和</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">holder&lt;double&gt;</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">都是</span><strong><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">placeholder</span></strong><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">的基类。所以只能期望程序员们清楚自己在做什么，要不然就给他个异常瞧瞧。</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><strong><span style="FONT-SIZE: 14pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">使用</span></strong><strong><span lang="EN-US" style="FONT-SIZE: 14pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">boost::any</span></strong><strong><span style="FONT-SIZE: 14pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">实现</span></strong><strong><span lang="EN-US" style="FONT-SIZE: 14pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual template</span></strong><strong><span style="FONT-SIZE: 14pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">成员函数</span></strong></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">如你所知，</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">C++</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">中没有提供</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual template function</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">。然而有时候你的确会有这种需要</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">,any</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">可以一定程度上满足这种需要，例如，</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><div style="BORDER-RIGHT: medium none; PADDING-RIGHT: 0cm; BORDER-TOP: windowtext 1pt solid; PADDING-LEFT: 4pt; BACKGROUND: #e6e6e6; PADDING-BOTTOM: 0cm; BORDER-LEFT: windowtext 1pt solid; PADDING-TOP: 1pt; BORDER-BOTTOM: medium none; mso-element: para-border-div; mso-border-top-alt: solid windowtext .5pt; mso-border-left-alt: solid windowtext .5pt"><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">class Base</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">public:</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual void Accept(boost::any anyData)</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">...</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">};</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">class Derived:public Base</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">public:</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual void Accept(boost::any anyData)</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">{</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 24pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">...</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; text-indent: 12pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">}</span></p><p style="border: medium none; padding: 0cm; margin: 0cm 0cm 0pt; background-position: initial initial; background-repeat: initial initial;"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">};</span></p></div><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-hansi-font-family: 宋体; mso-bidi-font-family: &apos;Courier New&apos;">&nbsp;</span></p><p style="MARGIN: 0cm 0cm 0pt; mso-layout-grid-align: none"><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">这样的</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">Accept</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">函数能够接受任意类型的数据，并且是</span><span lang="EN-US" style="FONT-SIZE: 12pt; FONT-FAMILY: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">virtual</span><span style="FONT-SIZE: 12pt; FONT-FAMILY: 宋体; mso-ascii-font-family: Verdana; mso-bidi-font-family: &apos;Courier New&apos;">函数。</span></p></div></en-note>]]></content><created>20131015T065650Z</created><updated>20131015T081754Z</updated><tag>Boost</tag><note-attributes><source-url>http://blog.csdn.net/pongba/article/details/82811</source-url></note-attributes></note><note><title>问题</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
在单文档程序中，派生CWnd创建一个窗口，并显示（进行消息循环）？
</en-note>]]></content><created>20131017T072154Z</created><updated>20131017T072245Z</updated></note><note><title>窗口程序添加菜单和工具栏</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
在窗口的OnInitialDialog函数中添加如下代码：
<div><br/></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp; &nbsp; &nbsp;</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">CMenu</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">mainMenu</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">;</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">mainMenu</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">LoadMenu</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">IDR_MAINMENU</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">SetMenu</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(&amp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">mainMenu</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt"><br/></span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#0000FF" face="Fixedsys" size="4"><span style="font-size:15pt">if</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(!</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">m_wndStatusBar</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">Create</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(</span></font><font color="#0000FF" face="Fixedsys" size="4"><span style="font-size:15pt">this</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">) ||</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">m_wndStatusBar</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SetIndicators</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">indicators</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#0000FF" face="Fixedsys" size="4"><span style="font-size:15pt">sizeof</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">indicators</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">)/</span></font><font color="#0000FF" face="Fixedsys" size="4"><span style="font-size:15pt">sizeof</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">UINT</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">)))</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">TRACE0</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(</span></font> <font color="#800000" face="Fixedsys" size="4"><span style="font-size:15pt">&quot;</span></font><font color="#800000" face="Times New Roman" size="4"><span style="font-size:15pt">未能创建状态栏</span></font><font color="#800000" face="Fixedsys" size="4"><span style="font-size:15pt">\n&quot;</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#0000FF" face="Fixedsys" size="4"><span style="font-size:15pt">return</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#008000" face="Fixedsys" size="4"><span style="font-size:15pt">//</span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:15pt">未能创建</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt"><br/></span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">CRect</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">rect</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">;</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">GetClientRect</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(&amp;</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">rect</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt"><br/></span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">m_wndStatusBar</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SetPaneInfo</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(0,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">ID_SEPARATOR</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SBPS_NORMAL</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">rect</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">Width</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">()/4);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">m_wndStatusBar</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SetPaneInfo</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(1,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">ID_INDICATOR_CAPS</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SBPS_NORMAL</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">rect</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">Width</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">()/4);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">m_wndStatusBar</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SetPaneInfo</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(2,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">ID_INDICATOR_NUM</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SBPS_NORMAL</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">rect</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">Width</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">()/4);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">m_wndStatusBar</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SetPaneInfo</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(3,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">ID_INDICATOR_SCRL</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SBPS_STRETCH</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,0);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">m_wndStatusBar</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SetPaneText</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(0,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">TEXT</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(</span></font><font color="#800000" face="Fixedsys" size="4"><span style="font-size:15pt">&quot;Test Caps&quot;</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">));</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">RepositionBars</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">AFX_IDW_CONTROLBAR_FIRST</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">AFX_IDW_CONTROLBAR_LAST</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">,</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">ID_INDICATOR_SCRL</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font face="Fixedsys" size="4"><span style="font-size:15pt">m_wndStatusBar</span></font><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">.</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">GetStatusBarCtrl</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">().</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">SetBkColor</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(</span></font><font face="Fixedsys" size="4"><span style="font-size:15pt">RGB</span></font> <font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">(180,180,180));</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#008000" face="Fixedsys" size="4"><span style="font-size:15pt">//m_wndStatusBar.MoveWindow(0,rect.bottom-20,rect.right,20);</span></font></div><div align="left"><font color="#010101" face="Fixedsys" size="4"><span style="font-size:15pt">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></font> <font color="#008000" face="Fixedsys" size="4"><span style="font-size:15pt">//m_wndStatusBar.ShowWindow(SW_SHOW);</span></font></div></en-note>]]></content><created>20131024T020136Z</created><updated>20131024T023740Z</updated></note><note><title>排序方法</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><ul><li><b style="font-size: 16px;">快速排序</b></li></ul><div>N个无序的元素，从第二个元素依次开始取值，设取值的是第m个元素，第1个到第m-1个元素是有序的，在第1个到第m-1个元素之间查找第m个元素要插入的位置n，把n到m-1之间的元素向后移动一个位置，把第m个元素拷贝到位置n</div><div>template&lt;typename Elem&gt;</div><div>void InsertionSort(Elem elems[],size_t n)</div><div>{</div><div>&nbsp; &nbsp; &nbsp;for(size_t i = 1; i &lt; n - 1; ++i)</div><div>&nbsp; &nbsp; &nbsp;{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //取的第i+1个元素</div><div>&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elem last = elems[i];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_t j = i - 1;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //为了精简代码，下面的过程把移动和查找放在一起完成，查找的是第一次比所取原始小的位置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //从第i个元素开始依次向后移动一个元素，直到没有元素或者当前元素比第i+1个元素小为止</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while(j &gt;= 0 &amp;&amp;&nbsp;elems[j] &gt; last)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elems[j+1] = elems[j];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;--j;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //把第i+1个元素插入到找到的位置之后</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[j+1] = last;</div><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div>}</div><div><br/></div><div><ul><li style="font-size: 16px;"><b>选择排序</b></li></ul></div><div>N个无序的元素e[N-1]，首先在e[0]~e[N-1]之间查找最小的元素的位置m，然后e[0]和e[m]的值交换，之后再e[1]~e[N-1]之间查找最小的元素位置m&apos;，然后e[1]和e[m&apos;]的值交换，按此方法直到只剩元素e[N-1]</div><div>template&lt;typename Elem&gt;</div><div>void SelectionSort(Elem elems[],size_t n)</div><div>{</div><div>&nbsp; &nbsp; &nbsp;for(size_t i = 0; i &lt; n; ++i)</div><div>&nbsp; &nbsp; &nbsp;{</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_t _t = i;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(size_t j = i; j &lt; n; ++j)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(elems[j] &gt; elems[_t])</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; continue;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;_t = j;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(i == _t)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;continue;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Elem e = elems[i];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[i] = elems[_t];</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems[_t] = e;</div><div>&nbsp; &nbsp; &nbsp;}</div><div>}</div><div><br/></div><div><br/></div><div><br/></div></en-note>]]></content><created>20131104T083113Z</created><updated>20131105T011425Z</updated><tag>算法</tag><tag>排序</tag></note><note><title>STL之算法</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><b>条件：</b><div><b>1.指定的范围内的原始有效</b></div><div><b>2.范围内所有的指针都可以解引用</b></div><div><b>3.结束位置可以从开始位置通过增量到达</b></div><div><b>4.范围内的元素有序<br/></b><ul><li><b>adjacent_find （1,2,3）</b></li></ul><div>在指定序列中查找相邻两个元素满足指定关系的记录（默认是相等关系），返回满足条件的第一个元素的位置，否则返回end</div><div><ul><li><b>binary_search（1,2,3,4）</b></li></ul>
在指定的有序序列中查找和指定元素值是否存在（默认是使用小于符号，否则在函数中要指定排序方法），存在返回true，否则返回false</div></div><div><ul><li><b>copy(1,2,3)</b></li></ul>
把指定范围内的元素复制到目标位置后，目标位置后要有足够的空间存放拷贝的元素，指定序列的结束位置不能在目标范围内，所以可以把容器的元素左移而不能右移（原始序列和目标位置重合），此函数只是改变迭代器的指向，不会向集合插入元素，返回目标序列最后一个位置+1</div><div><ul><li><b>count(1,2,3)</b></li></ul></div><div>在指定范围内查询指定值出现的次数，返回指定值出现的次数（根据迭代器类型确认返回的类型），容器中的元素对象必须定义等于操作符，count_if泛化了计数的条件，可以统计集合中满足特定条件的值的个数</div><div><ul><li><b>equal(1,2,3)</b></li></ul></div><div>判断两个指定序列是否相等或者是否满足指定条件下相等，相等返回true，否则返回false</div><div><ul><li>equal_range(1,2,3,4)</li></ul></div><div>在指定的有序序列中查找包含指定元素的位置区间，返回包含指定元素的位置区间（没找到会怎么样？），比较关系可以用户指定</div><div><ul><li>fill(1,2,3)</li></ul></div><div>把指定序列中的元素值设置为指定值</div><div><ul><li>fill_n(1,2,3)</li></ul></div><div>把从指定位置开始的指定个数的元素值设置为指定值</div><div><ul><li>find(1,2,3)</li></ul></div><div>在指定序列中查找指定值的位置并返回，如果没有则返回序列最后一个位置，find_if把比较与值相等泛化为满足指定断定函数</div><div><ul><li>find_end(1,2,3)</li></ul></div><div>在指定序列中查找另一个指定序列作为子序列最后一次出现的位置，find_first_of和其类似查找第一次出现的位置</div><div><ul><li>for_each(1,2,3)</li></ul></div><div>指定序列中的每一个元素上分别执行指定的函数对象，并返回此函数对象</div><div><ul><li>generate(1,2,3)</li></ul></div><div>为指定序列的元素填充指定函数产生的值，generate_n填充从指定位置开始的指定个元素</div><div><ul><li><br/></li></ul></div><div><br/></div></en-note>]]></content><created>20131216T012719Z</created><updated>20131217T062154Z</updated></note><note><title>过去曾经拥有，将来仍然可能，现在并不适合！</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
过去曾经拥有，将来仍然可能，现在并不适合！
<div><br/><div>当时间过去，女人们也许会忘记她们曾经义无反顾的爱过一个人，忘记了他的温柔，忘记了他为她们做的一切，她对他没<span style="background-color: rgb(255, 255, 102);">有</span>感觉，她不再爱他了。为什么会这样？原来她们的爱情白给了岁月，首先是爱情使她忘记了时间，然后是时间使她忘记爱情 。</div></div><div><br/></div><div style="text-align: left;">世界上最遥远的距离，不是生与死，而是我就站在你面前，你却不知道我爱你。</div><div style="text-align: left;">世界上最遥远的距离，不是我就站在你面前，你却不知道我爱你，而是明明知道彼此相爱，却不能在一起。</div><div style="text-align: left;">世界上最遥远的距离，不是明明知道彼此相爱，却不能在一起，而是明明无法抵挡这股想念，却还得故意装作丝毫没<b style="background-color: rgb(255, 255, 102);">有</b>把你放在心里。</div><div style="text-align: left;">世界上最遥远的距离，不是明明无法抵挡这股想念，却还得故意装作丝毫没<b style="background-color: rgb(255, 255, 102);">有</b>把你放在心里，而是用自己冷默的心，对爱你的人掘了一条无法跨越的沟渠。</div><div style="text-align: left;"><br/></div><div style="text-align: left;"><br/></div></en-note>]]></content><created>20131219T013906Z</created><updated>20131223T013017Z</updated><note-attributes><source-url>http://cache.baiducontent.com/c?m=9d78d513d9d437ae4f9b96690c66c0161243f6692bd6a0020fd6843be4732a445011e8ac26520774d4d20d6116ae394b9a872101411450b08cbf8e5ddccb855e2d9f5437676df65662d40de88b182a9b66d618feae6afaa7a062d2b9d2a49b0902dd53722bddaf9c5a77459672b64973b8f78e48635f11bbec3564fe4e775f9c3440c044eee0453441dea8&amp;p=8b2a97599c8b11a058ec9462464bcc&amp;newp=882a9544d69d12a05ab6c0214e5d9d231610db2151d0d71121&amp;user=baidu&amp;fm=sc&amp;query=%D3%D0%B9%D8%B0%AE%C7%E9%B5%C4%BE%AD%B5%E4%D0%A1%CB%B5&amp;qid=&amp;p1=14</source-url></note-attributes></note><note><title>悟空传</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
悟空传
<div><br/></div></en-note>]]></content><created>20131225T084327Z</created></note><note><title>网络</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
route print:打印路由表
<div>&nbsp;
<div>/etc/init.d/目录下的所示文件都是服务项，可执行，直接在文件名后加start/stop/restart进行操作</div><div><br/></div><div><br/></div></div></en-note>]]></content><created>20140324T012917Z</created><updated>20140325T034956Z</updated><note-attributes/></note><note><title>文件系统</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><p style="margin: 0px;">dd if=/dev/zero of=disk bs=1M count=1 ＃创建1MB的空间，并填充为0</p><p style="margin: 0px;">mkfs.ext2 disk ＃格式化为ext2分区，从输出信息中可以看见block大小为1024byte</p><p style="margin: 0px;">mount -o loop disk /mnt/ ＃挂载分区</p></en-note>]]></content><created>20140401T071145Z</created><updated>20140401T071148Z</updated><note-attributes><source-url>http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece7631046893b4c4380147d8c8c4668d4e419ce3b4c413037bfa6663f405a8e906b6075a94f5beefb30223c0123b59998d302dbac925f75ce786a6459db0144dc4ee58d4632c050872b9eb868e1ad804384daa5c4de2444bb27120a87e7fa2c1764cb78f1642693d08e3f164860b1fa406e&amp;p=93759a45d7c25ff313be9b7c155986&amp;newp=8d57dd0e9e904ead08e2947f0c42bb231610db2151d0d710&amp;user=baidu&amp;fm=sc&amp;query=ext2%CE%C4%BC%FE%CF%B5%CD%B3%BD%E1%B9%B9&amp;qid=&amp;p1=6</source-url></note-attributes></note><note><title>apt-get</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
apt-get install vim-gtk
</en-note>]]></content><created>20140414T054329Z</created><updated>20140414T054344Z</updated></note><note><title>vim</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
修改配色：
<div>配色文件在/usr/share/vim/vimXX/colors/
<div>colorscheme evening</div></div><div><br/></div><div>vim中输入命令:hi查看配色方案</div><div>输入命令 :hi PreProc ctermfg=darkcyan就可以修改配色</div><div>syntax on打开配色方案</div><div><br/></div><div>LS_COLORS环境变量配置ls命令结果的颜色</div><div>dircolors -p帮助配置</div></en-note>]]></content><created>20140414T054434Z</created><updated>20140414T060236Z</updated></note><note><title>gdb</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
gcc -g 打开调试选项
<div>gprof分析程序那一段执行最费时</div><div>编译时要用：gcc -pg 这样运行时会产生gmon.out文件，此文件用于gprof分析</div></en-note>]]></content><created>20140416T020211Z</created><updated>20140416T025059Z</updated></note><note><title>makefile</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>基本模式如下：</div><div>target:dependency &nbsp;</div><div>&nbsp; &nbsp; &nbsp;command</div><div><br/></div><div>定义与使用变量</div><div>DEFINE=var</div><div>$(DEFINE)</div><div><br/></div><div>特殊符号</div><div>$@ 此条目所有target</div><div>$&lt; 此条目所有denpendency</div><div>$^ 此条目第一个dependency</div><div><br/></div><div>make -n只显示要执行的命令，不实际执行</div><div>make -s 完全隐藏所有执行的命令，包括语句和结果</div><div>在makefile中命令前缀@可以隐藏命令，如：echo &quot;正在编译..&quot;会只显示&quot;正在编译..&quot;，&quot;echo&quot;不会回显</div><div><br/></div><div>在command中执行多条命令时，如果想前面命令的效果作用在后面的命令中，这些命令要写在一行，并用&quot;;&quot;分割</div><div>exec:</div><div>&nbsp; &nbsp; &nbsp;cd /etc;pwd</div><div><br/></div><div>在命令前加&quot;-&quot;，这样当此命令失败时，规制中的其他命令继续执行</div><div>make -i 这样可以忽略所有发生的错误，继续执行接下来的命令</div><div>make -k 这样发生错误时终止当前目标，继续其他目标的规制</div><div>下面不知道有什么作用</div><div><strike>而且在makefile中把命令标记为.IGNORE也可以，这样做时忽略此目标的错误，继续执行其他目标</strike></div><div><font face="Verdana"><br/></font></div><div><font face="Verdana">嵌套执行时，先切换到子目录再调用make，语法为</font></div><div><font face="Verdana">subsystem:</font></div><div>&nbsp; &nbsp; &nbsp;cd subdir &amp;&amp; $(MAKE)</div><div>or</div><div>subsystem:</div><div>&nbsp; &nbsp; &nbsp;$(MAKE) -C subdir</div><div>当切换目录时会有提示：</div><div>Entering directory /home/jingy/Code</div><div>Leaving directory /home/jingy/Code</div><div>$(MAKE) -w(--print-directory)打开此提示，-C选项也是打开此选项的，-s选项可以取消提示</div><div><br/></div><div><br/></div><div><font face="Verdana"><br/></font></div><div><font face="Verdana">跟我一起写 <b style="background-color: rgb(160, 255, 255);">Makefile</b><br/><br/><br/>
陈皓 (CSDN)<br/><br/>
概述<br/>
——<br/><br/>
什么是<b style="background-color: rgb(160, 255, 255);">makefile</b>？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，<b style="background-color: rgb(160, 255, 255);">makefile</b>还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写<b style="background-color: rgb(160, 255, 255);">makefile</b>了，会不会写<b style="background-color: rgb(160, 255, 255);">makefile</b>，从一个侧面说明了一个人是否具备完成大型工程的能力。<br/><br/>
因为，<b style="background-color: rgb(160, 255, 255);">makefile</b>关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，<b style="background-color: rgb(160, 255, 255);">makefile</b>定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为<b style="background-color: rgb(160, 255, 255);">makefile</b>就像一个Shell脚本一样，其中也可以执行操作系统的命令。<br/><br/><b style="background-color: rgb(160, 255, 255);">makefile</b>带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释<b style="background-color: rgb(160, 255, 255);">makefile</b>中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，<b style="background-color: rgb(255, 255, 102);">Linux</b>下GNU的make。可见，<b style="background-color: rgb(160, 255, 255);">makefile</b>都成为了一种在工程方面的编译方法。<br/><br/>
现在讲述如何写<b style="background-color: rgb(160, 255, 255);">makefile</b>的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat <b style="background-color: rgb(255, 255, 102);">Linux</b> 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。<br/><br/>
在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。<br/><br/><br/><br/>
关于程序的编译和链接<br/>
——————————<br/><br/>
在 此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。<br/><br/>
编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你 需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般 来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。<br/><br/>
链接时，主要是链接函数和全局变量，所以，我们可以使用这些中 间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给 中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。<br/><br/>
总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语 法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的Object File.<br/><br/>
好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。<br/><br/><br/><br/><b style="background-color: rgb(160, 255, 255);">Makefile</b> 介绍<br/>
———————<br/><br/>
make命令执行时，需要一个 <b style="background-color: rgb(160, 255, 255);">Makefile</b> 文件，以告诉make命令需要怎么样的去编译和链接程序。<br/><br/>
首先，我们用一个示例来说明<b style="background-color: rgb(160, 255, 255);">Makefile</b>的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个<b style="background-color: rgb(160, 255, 255);">Makefile</b>来告诉make命令如何编译和链接这几个文件。我们的规则是：<br/>
1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。<br/>
2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。<br/>
3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。<br/><br/>
只要我们的<b style="background-color: rgb(160, 255, 255);">Makefile</b>写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。<br/><br/><br/>
一、<b style="background-color: rgb(160, 255, 255);">Makefile</b>的规则<br/><br/>
在讲述这个<b style="background-color: rgb(160, 255, 255);">Makefile</b>之前，还是让我们先来粗略地看一看<b style="background-color: rgb(160, 255, 255);">Makefile</b>的规则。<br/><br/>
target ... : prerequisites ...<br/>
command<br/>
...<br/>
...<br/><br/>
target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。<br/><br/>
prerequisites就是，要生成那个target所需要的文件或是目标。<br/><br/>
command也就是make需要执行的命令。（任意的Shell命令）<br/><br/>
这 是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说 白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是<b style="background-color: rgb(160, 255, 255);">Makefile</b>的规则。也就是<b style="background-color: rgb(160, 255, 255);">Makefile</b>中最核心的内容。<br/><br/>
说到底，<b style="background-color: rgb(160, 255, 255);">Makefile</b>的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是<b style="background-color: rgb(160, 255, 255);">Makefile</b>的主线和核心，但要写好一个<b style="background-color: rgb(160, 255, 255);">Makefile</b>还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）<br/><br/><br/>
二、一个示例<br/><br/>
正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的<b style="background-color: rgb(160, 255, 255);">Makefile</b>应该是下面的这个样子的。<br/><br/>
edit : main.o kbd.o command.o display.o /<br/>
insert.o search.o files.o utils.o<br/>
cc -o edit main.o kbd.o command.o display.o /<br/>
insert.o search.o files.o utils.o<br/><br/>
main.o : main.c defs.h<br/>
cc -c main.c<br/>
kbd.o : kbd.c defs.h command.h<br/>
cc -c kbd.c<br/>
command.o : command.c defs.h command.h<br/>
cc -c command.c<br/>
display.o : display.c defs.h buffer.h<br/>
cc -c display.c<br/>
insert.o : insert.c defs.h buffer.h<br/>
cc -c insert.c<br/>
search.o : search.c defs.h buffer.h<br/>
cc -c search.c<br/>
files.o : files.c defs.h buffer.h command.h<br/>
cc -c files.c<br/>
utils.o : utils.c defs.h<br/>
cc -c utils.c<br/>
clean :<br/>
rm edit main.o kbd.o command.o display.o /<br/>
insert.o search.o files.o utils.o<br/><br/>
反斜杠（/）是换行符的意思。这样比较便于<b style="background-color: rgb(160, 255, 255);">Makefile</b>的易读。我们可以把这个内容保存在文件为“<b style="background-color: rgb(160, 255, 255);">Makefile</b>”或“<b style="background-color: rgb(160, 255, 255);">makefile</b>”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。<br/><br/>
在这个<b style="background-color: rgb(160, 255, 255);">makefile</b>中， 目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。<br/><br/>
在定义好依赖关系后，后续的那 一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会 比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者 target不存在的话，那么，make就会执行后续定义的命令。<br/><br/>
这里要说明一点的是，clean不是一个文件，它只不过是一个动作名 字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的 命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个<b style="background-color: rgb(160, 255, 255);">makefile</b>中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。<br/><br/><br/><br/>
三、make是如何工作的<br/><br/>
在默认的方式下，也就是我们只输入make命令。那么，<br/><br/>
1、make会在当前目录下找名字叫“<b style="background-color: rgb(160, 255, 255);">Makefile</b>”或“<b style="background-color: rgb(160, 255, 255);">makefile</b>”的文件。<br/>
2、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。<br/>
3、如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。<br/>
4、如果edit所依赖的.o文件也不存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）<br/>
5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。<br/><br/>
这 就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的 文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我 找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。<br/><br/>
通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。<br/><br/>
于 是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译 （也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被 重新链接了（详见edit目标文件后定义的命令）。<br/><br/>
而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。<br/><br/><br/>
四、<b style="background-color: rgb(160, 255, 255);">makefile</b>中使用变量<br/><br/>
在上面的例子中，先让我们看看edit的规则：<br/><br/>
edit : main.o kbd.o command.o display.o /<br/>
insert.o search.o files.o utils.o<br/>
cc -o edit main.o kbd.o command.o display.o /<br/>
insert.o search.o files.o utils.o<br/><br/>
我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的<b style="background-color: rgb(160, 255, 255);">makefile</b>并不复杂，所以在两个地方加也不累，但如果<b style="background-color: rgb(160, 255, 255);">makefile</b>变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了<b style="background-color: rgb(160, 255, 255);">makefile</b>的易维护，在<b style="background-color: rgb(160, 255, 255);">makefile</b>中我们可以使用变量。<b style="background-color: rgb(160, 255, 255);">makefile</b>的变量也就是一个字符串，理解成C语言中的宏可能会更好。<br/><br/>
比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在<b style="background-color: rgb(160, 255, 255);">makefile</b>一开始就这样定义：<br/><br/>
objects = main.o kbd.o command.o display.o /<br/>
insert.o search.o files.o utils.o<br/><br/>
于是，我们就可以很方便地在我们的<b style="background-color: rgb(160, 255, 255);">makefile</b>中以“$(objects)”的方式来使用这个变量了，于是我们的改良版<b style="background-color: rgb(160, 255, 255);">makefile</b>就变成下面这个样子：<br/><br/>
objects = main.o kbd.o command.o display.o /<br/>
insert.o search.o files.o utils.o<br/><br/>
edit : $(objects)<br/>
cc -o edit $(objects)<br/>
main.o : main.c defs.h<br/>
cc -c main.c<br/>
kbd.o : kbd.c defs.h command.h<br/>
cc -c kbd.c<br/>
command.o : command.c defs.h command.h<br/>
cc -c command.c<br/>
display.o : display.c defs.h buffer.h<br/>
cc -c display.c<br/>
insert.o : insert.c defs.h buffer.h<br/>
cc -c insert.c<br/>
search.o : search.c defs.h buffer.h<br/>
cc -c search.c<br/>
files.o : files.c defs.h buffer.h command.h<br/>
cc -c files.c<br/>
utils.o : utils.c defs.h<br/>
cc -c utils.c<br/>
clean :<br/>
rm edit $(objects)<br/><br/><br/>
于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。<br/><br/>
关于变量更多的话题，我会在后续给你一一道来。<br/><br/><br/>
五、让make自动推导<br/><br/>
GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。<br/><br/>
只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的<b style="background-color: rgb(160, 255, 255);">makefile</b>再也不用写得这么复杂。我们的是新的<b style="background-color: rgb(160, 255, 255);">makefile</b>又出炉了。<br/><br/><br/>
objects = main.o kbd.o command.o display.o /<br/>
insert.o search.o files.o utils.o<br/><br/>
edit : $(objects)<br/>
cc -o edit $(objects)<br/><br/>
main.o : defs.h<br/>
kbd.o : defs.h command.h<br/>
command.o : defs.h command.h<br/>
display.o : defs.h buffer.h<br/>
insert.o : defs.h buffer.h<br/>
search.o : defs.h buffer.h<br/>
files.o : defs.h buffer.h command.h<br/>
utils.o : defs.h<br/><br/>
.PHONY : clean<br/>
clean :<br/>
rm edit $(objects)<br/><br/>
这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。<br/><br/>
关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。<br/><br/><br/>
六、另类风格的<b style="background-color: rgb(160, 255, 255);">makefile</b><br/><br/>
即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的<b style="background-color: rgb(160, 255, 255);">makefile</b>吧。<br/><br/>
objects = main.o kbd.o command.o display.o /<br/>
insert.o search.o files.o utils.o<br/><br/>
edit : $(objects)<br/>
cc -o edit $(objects)<br/><br/>
$(objects) : defs.h<br/>
kbd.o command.o files.o : command.h<br/>
display.o insert.o search.o files.o : buffer.h<br/><br/>
.PHONY : clean<br/>
clean :<br/>
rm edit $(objects)<br/><br/>
这种风格，让我们的<b style="background-color: rgb(160, 255, 255);">makefile</b>变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</font></div><p><font face="verdana, arial, helvetica" size="2"><span style="FONT-SIZE: 12px">七、清空目标文件的规则<br/><br/>
每个<b style="background-color: rgb(160, 255, 255);">Makefile</b>中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：<br/><br/>
clean:<br/>
rm edit $(objects)<br/><br/>
更为稳健的做法是：<br/><br/>
.PHONY : clean<br/>
clean :<br/>
-rm edit $(objects)<br/><br/>
前 面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的 事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在 文件的最后”。<br/><br/><br/>
上面就是一个<b style="background-color: rgb(160, 255, 255);">makefile</b>的概貌，也是<b style="background-color: rgb(160, 255, 255);">makefile</b>的基础，下面还有很多<b style="background-color: rgb(160, 255, 255);">makefile</b>的相关细节，准备好了吗？准备好了就来。<br/><br/><b style="background-color: rgb(160, 255, 255);">Makefile</b> 总述<br/>
———————<br/><br/>
一、<b style="background-color: rgb(160, 255, 255);">Makefile</b>里有什么？<br/><br/><b style="background-color: rgb(160, 255, 255);">Makefile</b>里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。<br/><br/>
1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由<b style="background-color: rgb(160, 255, 255);">Makefile</b>的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。<br/><br/>
2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写<b style="background-color: rgb(160, 255, 255);">Makefile</b>，这是由make所支持的。<br/><br/>
3、变量的定义。在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当<b style="background-color: rgb(160, 255, 255);">Makefile</b>被执行时，其中的变量都会被扩展到相应的引用位置上。<br/><br/>
4、文件指示。其包括了三个部分，一个是在一个<b style="background-color: rgb(160, 255, 255);">Makefile</b>中引用另一个<b style="background-color: rgb(160, 255, 255);">Makefile</b>，就像C语言中的include一样；另一个是指根据某些情况指定<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。<br/><br/>
5、注释。<b style="background-color: rgb(160, 255, 255);">Makefile</b>中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的<b style="background-color: rgb(160, 255, 255);">Makefile</b>中使用“#”字符，可以用反斜框进行转义，如：“/#”。<br/><br/>
最后，还值得一提的是，在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的命令，必须要以[Tab]键开始。<br/><br/><br/>
二、<b style="background-color: rgb(160, 255, 255);">Makefile</b>的文件名<br/><br/>
默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“<b style="background-color: rgb(160, 255, 255);">makefile</b>”、“<b style="background-color: rgb(160, 255, 255);">Makefile</b>”的文件，找到了解释这个文件。在这三个文件名中，最好使用“<b style="background-color: rgb(160, 255, 255);">Makefile</b>”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“<b style="background-color: rgb(160, 255, 255);">makefile</b>”文件名敏感，但是基本上来说，大多数的make都支持“<b style="background-color: rgb(160, 255, 255);">makefile</b>”和“<b style="background-color: rgb(160, 255, 255);">Makefile</b>”这两种默认文件名。<br/><br/>
当然，你可以使用别的文件名来书写<b style="background-color: rgb(160, 255, 255);">Makefile</b>，比如：“Make.<b style="background-color: rgb(255, 255, 102);">Linux</b>”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的<b style="background-color: rgb(160, 255, 255);">Makefile</b>，你可以使用make的“-f”和“--file”参数，如：make -f Make.<b style="background-color: rgb(255, 255, 102);">Linux</b>或make --file Make.AIX。<br/><br/><br/>
三、引用其它的<b style="background-color: rgb(160, 255, 255);">Makefile</b><br/><br/>
在<b style="background-color: rgb(160, 255, 255);">Makefile</b>使用include关键字可以把别的<b style="background-color: rgb(160, 255, 255);">Makefile</b>包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：<br/><br/>
include &lt;filename&gt;<br/><br/>
filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）<br/><br/>
在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和&lt;filename&gt;可以用一个或多个空格隔开。举个例子，你有这样几个<b style="background-color: rgb(160, 255, 255);">Makefile</b>：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：<br/><br/>
include foo.make *.mk $(bar)<br/><br/>
等价于：<br/><br/>
include foo.make a.mk b.mk c.mk e.mk f.mk<br/><br/>
make命令开始时，会把找寻include所指出的其它<b style="background-color: rgb(160, 255, 255);">Makefile</b>，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：<br/><br/>
1、如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。<br/>
2、如果目录&lt;prefix&gt;/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。<br/><br/>
如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成<b style="background-color: rgb(160, 255, 255);">makefile</b>的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：<br/><br/>
-include &lt;filename&gt;<br/>
其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。<br/><br/><br/>
四、环境变量 MAKEFILES<br/><br/>
如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的<b style="background-color: rgb(160, 255, 255);">Makefile</b>，用空格分隔。只是，它和include不同的是，从这个环境变中引入的<b style="background-color: rgb(160, 255, 255);">Makefile</b>的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。<br/><br/>
但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的<b style="background-color: rgb(160, 255, 255);">Makefile</b>都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的<b style="background-color: rgb(160, 255, 255);">Makefile</b>出现了怪事，那么你可以看看当前环境中有没有定义这个变量。<br/><br/><br/>
五、make的工作方式<br/><br/>
GNU的make工作时的执行步骤入下：（想来其它的make也是类似）<br/><br/>
1、读入所有的<b style="background-color: rgb(160, 255, 255);">Makefile</b>。<br/>
2、读入被include的其它<b style="background-color: rgb(160, 255, 255);">Makefile</b>。<br/>
3、初始化文件中的变量。<br/>
4、推导隐晦规则，并分析所有规则。<br/>
5、为所有的目标文件创建依赖关系链。<br/>
6、根据依赖关系，决定哪些目标要重新生成。<br/>
7、执行生成命令。<br/><br/>
1-5 步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展 开，make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。<br/><br/>
当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。<br/><br/><br/><br/>
书写规则<br/>
————<br/><br/>
规则包含两个部分，一个是依赖关系，一个是生成目标的方法。<br/><br/>
在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，规则的顺序是很重要的，因为，<b style="background-color: rgb(160, 255, 255);">Makefile</b>中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。<br/><br/>
好了，还是让我们来看一看如何书写规则。<br/><br/><br/>
一、规则举例<br/><br/>
foo.o : foo.c defs.h # foo模块<br/>
cc -c -g foo.c<br/><br/>
看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：<br/><br/>
1、文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。<br/>
2、如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）<br/><br/><br/>
二、规则的语法<br/><br/>
targets : prerequisites<br/>
command<br/>
...<br/><br/>
或是这样：<br/><br/>
targets : prerequisites ; command<br/>
command<br/>
...<br/><br/>
targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。<br/><br/>
command是命令行，如果其不与“target<img alt="吐舌" border="0" src="http://www.itpub.net/images/smilies/13.gif" style="cursor: default;cursor: default;"/>rerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）<br/><br/>
prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。<br/><br/>
如果命令太长，你可以使用反斜框（‘/’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。<br/><br/>
一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。<br/><br/><br/>
三、在规则中使用通配符<br/><br/>
如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[...]”。这是和Unix的B-Shell是相同的。<br/><br/>
波 浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen /test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS 下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。<br/><br/>
通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“/”，如“/*”来表示真实的“*”字符，而不是任意长度的字符串。<br/><br/>
好吧，还是先来看几个例子吧：<br/><br/>
clean:<br/>
rm -f *.o<br/><br/>
上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。<br/><br/>
print: *.c<br/>
lpr -p $?<br/>
touch print<br/><br/>
上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。<br/><br/>
objects = *.o<br/><br/>
上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！objects的值就是“*.o”。<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：<br/><br/>
objects := $(wildcard *.o)<br/><br/>
这种用法由关键字“wildcard”指出，关于<b style="background-color: rgb(160, 255, 255);">Makefile</b>的关键字，我们将在后面讨论。<br/><br/><br/>
四、文件搜寻<br/><br/>
在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。<br/><br/><b style="background-color: rgb(160, 255, 255);">Makefile</b>文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。<br/><br/>
VPATH = src:../headers<br/><br/>
上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）<br/><br/>
另 一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个 VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：<br/><br/>
1、vpath &lt;pattern&gt; &lt;directories&gt;<br/><br/>
为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;。<br/><br/>
2、vpath &lt;pattern&gt;<br/><br/>
清除符合模式&lt;pattern&gt;的文件的搜索目录。<br/><br/>
3、vpath<br/><br/>
清除所有已被设置好了的文件搜索目录。<br/><br/>
vapth 使用方法中的&lt;pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文 件。&lt;pattern&gt;指定了要搜索的文件集，而&lt;directories&gt;则指定了&lt;pattern&gt;的文件集的 搜索的目录。例如：<br/><br/>
vpath %.h ../headers<br/><br/>
该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）<br/><br/>
我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt;pattern&gt;，或是被重复了的&lt;pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：<br/><br/>
vpath %.c foo<br/>
vpath % blish<br/>
vpath %.c bar<br/><br/>
其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。<br/><br/>
vpath %.c foo:bar<br/>
vpath % blish<br/><br/>
而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。<br/><br/><br/>
五、伪目标<br/><br/>
最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，<br/><br/>
clean:<br/>
rm *.o temp<br/><br/>
正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）<br/><br/>
因 为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它 是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。<br/><br/>
当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。<br/><br/>
.PHONY : clean<br/><br/>
只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：<br/><br/>
.PHONY: clean<br/>
clean:<br/>
rm *.o temp<br/><br/>
伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的<b style="background-color: rgb(160, 255, 255);">Makefile</b>需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，那么你可以使用“伪目标”这个特性：<br/><br/>
all : prog1 prog2 prog3<br/>
.PHONY : all<br/><br/>
prog1 : prog1.o utils.o<br/>
cc -o prog1 prog1.o utils.o<br/><br/>
prog2 : prog2.o<br/>
cc -o prog2 prog2.o<br/><br/>
prog3 : prog3.o sort.o utils.o<br/>
cc -o prog3 prog3.o sort.o utils.o<br/><br/>
我们知道，<b style="background-color: rgb(160, 255, 255);">Makefile</b>中 的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标 就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。<br/><br/>
随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：<br/><br/>
.PHONY: cleanall cleanobj cleandiff<br/><br/>
cleanall : cleanobj cleandiff<br/>
rm program<br/><br/>
cleanobj :<br/>
rm *.o<br/><br/>
cleandiff :<br/>
rm *.diff<br/><br/>
“make clean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。<br/><br/>
六、多目标<br/><br/><b style="background-color: rgb(160, 255, 255);">Makefile</b>的 规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目 标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表 示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。<br/><br/>
bigoutput littleoutput : text.g<br/>
generate text.g -$(subst output,,$@) &gt; $@<br/><br/>
上述规则等价于：<br/><br/>
bigoutput : text.g<br/>
generate text.g -big &gt; bigoutput<br/>
littleoutput : text.g<br/>
generate text.g -little &gt; littleoutput<br/><br/>
其中，-$(subst output,,$@)中的“$”表示执行一个<b style="background-color: rgb(160, 255, 255);">Makefile</b>的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。<br/><br/><br/>
七、静态模式<br/><br/>
静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：<br/><br/>
&lt;targets ...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;<br/>
&lt;commands&gt;<br/>
...<br/><br/><br/>
targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。<br/><br/>
target-parrtern是指明了targets的模式，也就是的目标集模式。<br/><br/>
prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。<br/><br/>
这 样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的&lt;target-parrtern&gt;定义成“%.o”，意思是 我们的&lt;target&gt;集合中都是以“.o”结尾的，而如果我们的&lt;prereq-parrterns&gt;定义成“%.c”，意思 是对&lt;target-parrtern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;target-parrtern&gt;模式 中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。<br/><br/>
所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“/”进行转义，来标明真实的“%”字符。<br/><br/>
看一个例子：<br/><br/>
objects = foo.o bar.o<br/><br/>
all: $(objects)<br/><br/>
$(objects): %.o: %.c<br/>
$(CC) -c $(CFLAGS) $&lt; -o $@<br/><br/><br/>
上 面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：<br/><br/>
foo.o : foo.c<br/>
$(CC) -c $(CFLAGS) foo.c -o foo.o<br/>
bar.o : bar.c<br/>
$(CC) -c $(CFLAGS) bar.c -o bar.o<br/><br/>
试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：<br/><br/><br/>
files = foo.elc bar.o lose.o<br/><br/>
$(filter %.o,$(files)): %.o: %.c<br/>
$(CC) -c $(CFLAGS) $&lt; -o $@<br/>
$(filter %.elc,$(files)): %.elc: %.el<br/>
emacs -f batch-byte-compile $&lt;<br/><br/><br/>
$(filter %.o,$(files))表示调用<b style="background-color: rgb(160, 255, 255);">Makefile</b>的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了<b style="background-color: rgb(160, 255, 255);">Makefile</b>中更大的弹性。<br/><br/><br/>
八、自动生成依赖性<br/><br/>
在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include &quot;defs.h&quot;”，那么我们的依赖关系应该是：<br/><br/>
main.o : main.c defs.h<br/><br/>
但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改<b style="background-color: rgb(160, 255, 255);">Makefile</b>，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：<br/><br/>
cc -M main.c<br/><br/>
其输出是：<br/><br/>
main.o : main.c defs.h<br/><br/>
于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。<br/><br/>
gcc -M main.c的输出是：<br/><br/>
main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h /<br/>
/usr/include/sys/cdefs.h /usr/include/gnu/stubs.h /<br/>
/usr/lib/gcc-lib/i486-suse-<b style="background-color: rgb(255, 255, 102);">linux</b>/2.95.3/include/stddef.h /<br/>
/usr/include/bits/types.h /usr/include/bits/pthreadtypes.h /<br/>
/usr/include/bits/sched.h /usr/include/libio.h /<br/>
/usr/include/_G_config.h /usr/include/wchar.h /<br/>
/usr/include/bits/wchar.h /usr/include/gconv.h /<br/>
/usr/lib/gcc-lib/i486-suse-<b style="background-color: rgb(255, 255, 102);">linux</b>/2.95.3/include/stdarg.h /<br/>
/usr/include/bits/stdio_lim.h<br/><br/><br/>
gcc -MM main.c的输出则是：<br/><br/>
main.o: main.c defs.h<br/><br/>
那么，编译器的这个功能如何与我们的<b style="background-color: rgb(160, 255, 255);">Makefile</b>联系在一起呢。因为这样一来，我们的<b style="background-color: rgb(160, 255, 255);">Makefile</b>也要根据这些源文件重新生成，让<b style="background-color: rgb(160, 255, 255);">Makefile</b>自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的<b style="background-color: rgb(160, 255, 255);">Makefile</b>文件，[.d]文件中就存放对应[.c]文件的依赖关系。<br/><br/>
于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，这样，我们就可以自动化地生成每个文件的依赖关系了。<br/><br/>
这里，我们给出了一个模式规则来产生[.d]文件：<br/><br/>
%.d: %.c<br/>
@set -e; rm -f $@; /<br/>
$(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; /<br/>
sed &apos;s,/($*/)/.o[ :]*,/1.o $@ : ,g&apos; &lt; $@.$$$$ &gt; $@; /<br/>
rm -f $@.$$$$<br/><br/><br/>
这 个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式 “%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，“$$$$”意为一个随机编号，第二行生成的文件有可能是 “name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。<br/><br/>
总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：<br/><br/>
main.o : main.c defs.h<br/><br/>
转成：<br/><br/>
main.o main.d : main.c defs.h<br/><br/>
于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主<b style="background-color: rgb(160, 255, 255);">Makefile</b>中。我们可以使用<b style="background-color: rgb(160, 255, 255);">Makefile</b>的“include”命令，来引入别的<b style="background-color: rgb(160, 255, 255);">Makefile</b>文件（前面讲过），例如：<br/><br/>
sources = foo.c bar.c<br/><br/>
include $(sources:.c=.d)<br/><br/>
上 述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成 [.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的 目标会成为默认目标。</span></font></p><p>&nbsp;</p><p><font face="verdana, arial, helvetica" size="2"><span style="FONT-SIZE: 12px">书写命令<br/>
————<br/><br/>
每 条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟 在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。<br/><br/>
我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。<br/><br/>
一、显示命令<br/><br/>
通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：<br/><br/>
@echo 正在编译XXX模块......<br/><br/>
当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令，如果没有“@”，那么，make将输出：<br/><br/>
echo 正在编译XXX模块......<br/>
正在编译XXX模块......<br/><br/>
如果make执行时，带入make参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的<b style="background-color: rgb(160, 255, 255);">Makefile</b>，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。<br/><br/>
而make参数“-s”或“--slient”则是全面禁止命令的显示。<br/><br/><br/><br/>
二、命令执行<br/><br/>
当 依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令 时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而 应该把这两条命令写在一行上，用分号分隔。如：<br/><br/>
示例一：<br/>
exec:<br/>
cd /home/hchen<br/>
pwd<br/><br/>
示例二：<br/>
exec:<br/>
cd /home/hchen; pwd<br/><br/>
当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的<b style="background-color: rgb(160, 255, 255);">Makefile</b>目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。<br/><br/>
make 一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS- DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所 指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS- DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。<br/><br/><br/><br/>
三、命令出错<br/><br/>
每 当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功 完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。<br/><br/>
有些时 候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存 在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。<br/><br/>
为了做到这一点，忽略命令的出错，我们可以在<b style="background-color: rgb(160, 255, 255);">Makefile</b>的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：<br/><br/>
clean:<br/>
-rm -f *.o<br/><br/>
还有一个全局的办法是，给make加上“-i”或是“--ignore-errors”参数，那么，<b style="background-color: rgb(160, 255, 255);">Makefile</b>中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。<br/><br/>
还有一个要提一下的make的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。<br/><br/><br/><br/>
四、嵌套执行make<br/><br/>
在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的<b style="background-color: rgb(160, 255, 255);">Makefile</b>，这有利于让我们的<b style="background-color: rgb(160, 255, 255);">Makefile</b>变得更加地简洁，而不至于把所有的东西全部写在一个<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，这样会很难维护我们的<b style="background-color: rgb(160, 255, 255);">Makefile</b>，这个技术对于我们模块编译和分段编译有着非常大的好处。<br/><br/>
例如，我们有一个子目录叫subdir，这个目录下有个<b style="background-color: rgb(160, 255, 255);">Makefile</b>文件，来指明了这个目录下文件的编译规则。那么我们总控的<b style="background-color: rgb(160, 255, 255);">Makefile</b>可以这样书写：<br/><br/>
subsystem:<br/>
cd subdir &amp;&amp; $(MAKE)<br/><br/>
其等价于：<br/><br/>
subsystem:<br/>
$(MAKE) -C subdir<br/><br/>
定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。<br/><br/>
我们把这个<b style="background-color: rgb(160, 255, 255);">Makefile</b>叫做“总控<b style="background-color: rgb(160, 255, 255);">Makefile</b>”，总控<b style="background-color: rgb(160, 255, 255);">Makefile</b>的变量可以传递到下级的<b style="background-color: rgb(160, 255, 255);">Makefile</b>中（如果你显示的声明），但是不会覆盖下层的<b style="background-color: rgb(160, 255, 255);">Makefile</b>中所定义的变量，除非指定了“-e”参数。<br/><br/>
如果你要传递变量到下级<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，那么你可以使用这样的声明：<br/><br/>
export &lt;variable ...&gt;<br/><br/>
如果你不想让某些变量传递到下级<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，那么你可以这样声明：<br/><br/>
unexport &lt;variable ...&gt;<br/><br/>
如：<br/><br/>
示例一：<br/><br/>
export variable = value<br/><br/>
其等价于：<br/><br/>
variable = value<br/>
export variable<br/><br/>
其等价于：<br/><br/>
export variable := value<br/><br/>
其等价于：<br/><br/>
variable := value<br/>
export variable<br/><br/>
示例二：<br/><br/>
export variable += value<br/><br/>
其等价于：<br/><br/>
variable += value<br/>
export variable<br/><br/>
如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。<br/><br/>
需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控<b style="background-color: rgb(160, 255, 255);">Makefile</b>”时有make参数或是在上层<b style="background-color: rgb(160, 255, 255);">Makefile</b>中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，这是一个系统级的环境变量。<br/><br/>
但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关<b style="background-color: rgb(160, 255, 255);">Makefile</b>参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：<br/><br/>
subsystem:<br/>
cd subdir &amp;&amp; $(MAKE) MAKEFLAGS=<br/><br/>
如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。<br/><br/>
还 有一个在“嵌套执行”中比较有用的参数，“-w”或是“--print-directory”会在make的过程中输出一些信息，让你看到目前的工作目 录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：<br/><br/>
make: Entering directory `/home/hchen/gnu/make&apos;.<br/><br/>
而在完成下层make后离开目录时，我们会看到：<br/><br/>
make: Leaving directory `/home/hchen/gnu/make&apos;<br/><br/>
当你使用“-C”参数来指定make下层<b style="background-color: rgb(160, 255, 255);">Makefile</b>时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。<br/><br/><br/><br/>
五、定义命令包<br/><br/>
如果<b style="background-color: rgb(160, 255, 255);">Makefile</b>中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：<br/><br/>
define run-yacc<br/>
yacc $(firstword $^)<br/>
mv y.tab.c $@<br/>
endef<br/><br/>
这里，“run-yacc”是这个命令包的名字，其不要和<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。<br/><br/>
foo.c : foo.y<br/>
$(run-yacc)<br/><br/>
我 们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就 是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。<br/><br/>
使用变量<br/>
————<br/><br/>
在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中改变其值。在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，变量可以使用在“目标”，“依赖目标”，“命令”或是<b style="background-color: rgb(160, 255, 255);">Makefile</b>的其它部分中。<br/><br/>
变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的<b style="background-color: rgb(160, 255, 255);">Makefile</b>的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。<br/><br/>
有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是自动化变量，我会在后面介绍。<br/><br/>
一、变量的基础<br/><br/>
变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。<br/><br/>
变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：<br/><br/>
objects = program.o foo.o utils.o<br/>
program : $(objects)<br/>
cc -o program $(objects)<br/><br/>
$(objects) : defs.h<br/><br/>
变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：<br/><br/>
foo = c<br/>
prog.o : prog.$(foo)<br/>
$(foo)$(foo) -$(foo) prog.$(foo)<br/><br/>
展开后得到：<br/><br/>
prog.o : prog.c<br/>
cc -c prog.c<br/><br/>
当然，千万不要在你的<b style="background-color: rgb(160, 255, 255);">Makefile</b>中这样干，这里只是举个例子来表明<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。<br/><br/>
另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。<br/><br/><br/>
二、变量中的变量<br/><br/>
在定义变量的值时，我们可以使用其它变量来构造变量的值，在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中有两种方式来在用变量定义变量的值。<br/><br/>
先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：<br/><br/>
foo = $(bar)<br/>
bar = $(ugh)<br/>
ugh = Huh?<br/><br/>
all:<br/>
echo $(foo)<br/><br/>
我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。<br/><br/>
这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：<br/><br/>
CFLAGS = $(include_dirs) -O<br/>
include_dirs = -Ifoo -Ibar<br/><br/>
当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：<br/><br/>
CFLAGS = $(CFLAGS) -O<br/><br/>
或：<br/><br/>
A = $(B)<br/>
B = $(A)<br/><br/>
这 会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我 们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函 数会被调用多少次。<br/><br/>
为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：<br/><br/>
x := foo<br/>
y := $(x) bar<br/>
x := later<br/><br/>
其等价于：<br/><br/>
y := foo bar<br/>
x := later<br/><br/>
值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：<br/><br/>
y := $(x) bar<br/>
x := foo<br/><br/>
那么，y的值是“bar”，而不是“foo bar”。<br/><br/>
上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：<br/><br/>
ifeq (0,${MAKELEVEL})<br/>
cur-dir := $(shell pwd)<br/>
whoami := $(shell whoami)<br/>
host-type := $(shell arch)<br/>
MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}<br/>
endif<br/><br/>
关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前<b style="background-color: rgb(160, 255, 255);">Makefile</b>的调用层数。<br/><br/>
下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：<br/><br/>
nullstring :=<br/>
space := $(nullstring) # end of the line<br/><br/>
nullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的 使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：<br/><br/>
dir := /foo/bar # directory to put the frobs in<br/><br/>
dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。<br/><br/>
还有一个比较有用的操作符是“?=”，先看示例：<br/><br/>
FOO ?= bar<br/><br/>
其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：<br/><br/>
ifeq ($(origin FOO), undefined)<br/>
FOO = bar<br/>
endif<br/><br/><br/>
三、变量高级用法<br/><br/>
这里介绍两种变量的高级使用方法，第一种是变量值的替换。<br/><br/>
我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。<br/><br/>
还是看一个示例吧：<br/><br/>
foo := a.o b.o c.o<br/>
bar := $(foo:.o=.c)<br/><br/>
这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。<br/><br/>
另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：<br/><br/>
foo := a.o b.o c.o<br/>
bar := $(foo:%.o=%.c)<br/><br/>
这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。<br/><br/>
第二种高级用法是——“把变量的值再当成变量”。先看一个例子：<br/><br/>
x = y<br/>
y = z<br/>
a := $($(x))<br/><br/>
在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）<br/><br/>
我们还可以使用更多的层次：<br/><br/>
x = y<br/>
y = z<br/>
z = u<br/>
a := $($($(x)))<br/><br/>
这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。<br/><br/>
让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：<br/><br/>
x = $(y)<br/>
y = z<br/>
z = Hello<br/>
a := $($(x))<br/><br/>
这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。<br/><br/>
再复杂一点，我们再加上函数：<br/><br/>
x = variable1<br/>
variable2 := Hello<br/>
y = $(subst 1,2,$(x))<br/>
z = y<br/>
a := $($($(z)))<br/><br/>
这 个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于 是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值——“Hello”。 （喔，好不容易）<br/><br/>
在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：<br/><br/>
first_second = Hello<br/>
a = first<br/>
b = second<br/>
all = $($a_$b)<br/><br/>
这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。<br/><br/>
再来看看结合第一种技术的例子：<br/><br/>
a_objects := a.o b.o c.o<br/>
1_objects := 1.o 2.o 3.o<br/><br/>
sources := $($(a1)_objects:.o=.c)<br/><br/>
这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。<br/><br/>
再来看一个这种技术和“函数”与“条件语句”一同使用的例子：<br/><br/>
ifdef do_sort<br/>
func := sort<br/>
else<br/>
func := strip<br/>
endif<br/><br/>
bar := a d b g q c<br/><br/>
foo := $($(func) $(bar))<br/><br/>
这 个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d b g q c)，调用的就是strip函数。<br/><br/>
当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：<br/><br/>
dir = foo<br/>
$(dir)_sources := $(wildcard $(dir)/*.c)<br/>
define $(dir)_print<br/>
lpr $($(dir)_sources)<br/>
endef<br/><br/>
这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。<br/><br/><br/>
四、追加变量值<br/><br/>
我们可以使用“+=”操作符给变量追加值，如：<br/><br/>
objects = main.o foo.o bar.o utils.o<br/>
objects += another.o<br/><br/>
于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）<br/><br/>
使用“+=”操作符，可以模拟为下面的这种例子：<br/><br/>
objects = main.o foo.o bar.o utils.o<br/>
objects := $(objects) another.o<br/><br/>
所不同的是，用“+=”更为简洁。<br/><br/>
如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：<br/><br/>
variable := value<br/>
variable += more<br/><br/>
等价于：<br/><br/>
variable := value<br/>
variable := $(variable) more<br/><br/>
但如果是这种情况：<br/><br/>
variable = value<br/>
variable += more<br/><br/>
由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。<br/><br/><br/>
五、override 指示符<br/><br/>
如果有变量是通常make的命令行参数设置的，那么<b style="background-color: rgb(160, 255, 255);">Makefile</b>中对这个变量的赋值会被忽略。如果你想在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：<br/><br/>
override &lt;variable&gt; = &lt;value&gt;<br/><br/>
override &lt;variable&gt; := &lt;value&gt;<br/><br/>
当然，你还可以追加：<br/><br/>
override &lt;variable&gt; += &lt;more text&gt;<br/><br/>
对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：<br/><br/>
override define foo<br/>
bar<br/>
endef<br/><br/>
六、多行变量<br/><br/>
还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。<br/><br/>
define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文 字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命 令。<br/><br/>
下面的这个示例展示了define的用法：<br/><br/>
define two-lines<br/>
echo foo<br/>
echo $(bar)<br/>
endef<br/><br/><br/>
七、环境变量<br/><br/>
make运行时的系统环境变量可以在make开始运行时被载入到<b style="background-color: rgb(160, 255, 255);">Makefile</b>文件中，但是如果<b style="background-color: rgb(160, 255, 255);">Makefile</b>中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖<b style="background-color: rgb(160, 255, 255);">Makefile</b>中定义的变量）<br/><br/>
因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的<b style="background-color: rgb(160, 255, 255);">Makefile</b>中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果<b style="background-color: rgb(160, 255, 255);">Makefile</b>中定义了CFLAGS，那么则会使用<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。<br/><br/>
当make嵌套调用时（参见前面的“嵌套调用”章节），上层<b style="background-color: rgb(160, 255, 255);">Makefile</b>中定义的变量会以系统环境变量的方式传递到下层的<b style="background-color: rgb(160, 255, 255);">Makefile</b>中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层<b style="background-color: rgb(160, 255, 255);">Makefile</b>传递，则需要使用exprot关键字来声明。（参见前面章节）<br/><br/>
当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的<b style="background-color: rgb(160, 255, 255);">Makefile</b>时，拥有的是同一套系统变量，这可能会带来更多的麻烦。<br/><br/><br/>
八、目标变量<br/><br/>
前面我们所讲的在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。<br/><br/>
当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。<br/><br/>
其语法是：<br/><br/>
&lt;target ...&gt; : &lt;variable-assignment&gt;<br/><br/>
&lt;target ...&gt; : overide &lt;variable-assignment&gt;<br/><br/>
&lt;variable-assignment&gt;可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。<br/><br/>
这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：<br/><br/>
prog : CFLAGS = -g<br/>
prog : prog.o foo.o bar.o<br/>
$(CC) $(CFLAGS) prog.o foo.o bar.o<br/><br/>
prog.o : prog.c<br/>
$(CC) $(CFLAGS) prog.c<br/><br/>
foo.o : foo.c<br/>
$(CC) $(CFLAGS) foo.c<br/><br/>
bar.o : bar.c<br/>
$(CC) $(CFLAGS) bar.c<br/><br/>
在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”<br/><br/><br/>
九、模式变量<br/><br/>
在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。<br/><br/>
我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：<br/><br/>
%.o : CFLAGS = -O<br/><br/>
同样，模式变量的语法和“目标变量”一样：<br/><br/>
&lt;pattern ...&gt; : &lt;variable-assignment&gt;<br/><br/>
&lt;pattern ...&gt; : override &lt;variable-assignment&gt;<br/><br/>
override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</span></font></p><p><font face="verdana, arial, helvetica" size="2"><span style="FONT-SIZE: 12px"><font face="verdana, arial, helvetica" size="2"><span style="FONT-SIZE: 12px">使用条件判断<br/>
——————<br/><br/>
使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。<br/><br/>
一、示例<br/><br/>
下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。<br/><br/>
libs_for_gcc = -lgnu<br/>
normal_libs =<br/><br/>
foo: $(objects)<br/>
ifeq ($(CC),gcc)<br/>
$(CC) -o foo $(objects) $(libs_for_gcc)<br/>
else<br/>
$(CC) -o foo $(objects) $(normal_libs)<br/>
endif<br/><br/>
可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。<br/><br/>
我 们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数， 以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。<br/><br/>
当我们的变量$(CC)值是“gcc”时，目标foo的规则是：<br/><br/>
foo: $(objects)<br/>
$(CC) -o foo $(objects) $(libs_for_gcc)<br/><br/>
而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：<br/><br/>
foo: $(objects)<br/>
$(CC) -o foo $(objects) $(normal_libs)<br/><br/>
当然，我们还可以把上面的那个例子写得更简洁一些：<br/><br/>
libs_for_gcc = -lgnu<br/>
normal_libs =<br/><br/>
ifeq ($(CC),gcc)<br/>
libs=$(libs_for_gcc)<br/>
else<br/>
libs=$(normal_libs)<br/>
endif<br/><br/>
foo: $(objects)<br/>
$(CC) -o foo $(objects) $(libs)<br/><br/><br/>
二、语法<br/><br/>
条件表达式的语法为：<br/><br/>
&lt;conditional-directive&gt;<br/>
&lt;text-if-true&gt;<br/>
endif<br/><br/>
以及：<br/><br/>
&lt;conditional-directive&gt;<br/>
&lt;text-if-true&gt;<br/>
else<br/>
&lt;text-if-false&gt;<br/>
endif<br/><br/>
其中&lt;conditional-directive&gt;表示条件关键字，如“ifeq”。这个关键字有四个。<br/><br/>
第一个是我们前面所见过的“ifeq”<br/><br/>
ifeq (&lt;arg1&gt;, &lt;arg2&gt; )<br/>
ifeq &apos;&lt;arg1&gt;&apos; &apos;&lt;arg2&gt;&apos;<br/>
ifeq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;<br/>
ifeq &quot;&lt;arg1&gt;&quot; &apos;&lt;arg2&gt;&apos;<br/>
ifeq &apos;&lt;arg1&gt;&apos; &quot;&lt;arg2&gt;&quot;<br/><br/>
比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：<br/><br/>
ifeq ($(strip $(foo)),)<br/>
&lt;text-if-empty&gt;<br/>
endif<br/><br/>
这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么&lt;text-if-empty&gt;就生效。<br/><br/>
第二个条件关键字是“ifneq”。语法是：<br/><br/>
ifneq (&lt;arg1&gt;, &lt;arg2&gt; )<br/>
ifneq &apos;&lt;arg1&gt;&apos; &apos;&lt;arg2&gt;&apos;<br/>
ifneq &quot;&lt;arg1&gt;&quot; &quot;&lt;arg2&gt;&quot;<br/>
ifneq &quot;&lt;arg1&gt;&quot; &apos;&lt;arg2&gt;&apos;<br/>
ifneq &apos;&lt;arg1&gt;&apos; &quot;&lt;arg2&gt;&quot;<br/><br/>
其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。<br/><br/>
第三个条件关键字是“ifdef”。语法是：<br/><br/>
ifdef &lt;variable-name&gt;<br/><br/>
如 果变量&lt;variable-name&gt;的值非空，那到表达式为真。否则，表达式为假。当然，&lt;variable-name&gt;同样 可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：<br/><br/>
示例一：<br/>
bar =<br/>
foo = $(bar)<br/>
ifdef foo<br/>
frobozz = yes<br/>
else<br/>
frobozz = no<br/>
endif<br/><br/>
示例二：<br/>
foo =<br/>
ifdef foo<br/>
frobozz = yes<br/>
else<br/>
frobozz = no<br/>
endif<br/><br/>
第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。<br/><br/>
第四个条件关键字是“ifndef”。其语法是：<br/><br/>
ifndef &lt;variable-name&gt;<br/><br/>
这个我就不多说了，和“ifdef”是相反的意思。<br/><br/>
在&lt;conditional-directive&gt;这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以[Tab]键开始就行了。<br/><br/>
特别注意的是，make是在读取<b style="background-color: rgb(160, 255, 255);">Makefile</b>时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。<br/><br/>
而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。<br/><br/><br/><br/>
使用函数<br/>
————<br/><br/>
在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。<br/><br/><br/>
一、函数的调用语法<br/><br/>
函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：<br/><br/>
$(&lt;function&gt; &lt;arguments&gt; )<br/><br/>
或是<br/><br/>
${&lt;function&gt; &lt;arguments&gt;}<br/><br/>
这 里，&lt;function&gt;就是函数名，make支持的函数不多。&lt;arguments&gt;是函数的参数，参数间以逗号“,”分隔， 而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量， 为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。<br/><br/>
还是来看一个示例：<br/><br/>
comma:= ,<br/>
empty:=<br/>
space:= $(empty) $(empty)<br/>
foo:= a b c<br/>
bar:= $(subst $(space),$(comma),$(foo))<br/><br/>
在 这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个 参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“a,b,c”。<br/><br/><br/>
二、字符串处理函数<br/><br/>
$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt; )<br/><br/>
名称：字符串替换函数——subst。<br/>
功能：把字串&lt;text&gt;中的&lt;from&gt;字符串替换成&lt;to&gt;。<br/>
返回：函数返回被替换过后的字符串。<br/><br/>
示例：<br/><br/>
$(subst ee,EE,feet on the street)，<br/><br/>
把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt”。<br/><br/><br/>
$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt; )<br/><br/>
名称：模式字符串替换函数——patsubst。<br/>
功 能：查找&lt;text&gt;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&lt;pattern&gt;，如果匹配 的话，则以&lt;replacement&gt;替换。这里，&lt;pattern&gt;可以包括通配符“%”，表示任意长度的字串。如 果&lt;replacement&gt;中也包含“%”，那么，&lt;replacement&gt;中的这个“%”将 是&lt;pattern&gt;中的那个“%”所代表的字串。（可以用“/”来转义，以“/%”来表示真实含义的“%”字符）<br/>
返回：函数返回被替换过后的字符串。<br/><br/>
示例：<br/><br/>
$(patsubst %.c,%.o,x.c.c bar.c)<br/><br/>
把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”<br/><br/>
备注：<br/><br/>
这和我们前面“变量章节”说过的相关知识有点相似。如：<br/><br/>
“$(var:&lt;pattern&gt;=&lt;replacement&gt; )”<br/>
相当于<br/>
“$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,$(var))”，<br/><br/>
而“$(var: &lt;suffix&gt;=&lt;replacement&gt; )”<br/>
则相当于<br/>
“$(patsubst %&lt;suffix&gt;,%&lt;replacement&gt;,$(var))”。<br/><br/>
例如有：objects = foo.o bar.o baz.o，<br/>
那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。<br/><br/>
$(strip &lt;string&gt; )<br/><br/>
名称：去空格函数——strip。<br/>
功能：去掉&lt;string&gt;字串中开头和结尾的空字符。<br/>
返回：返回被去掉空格的字符串值。<br/>
示例：<br/><br/>
$(strip a b c )<br/><br/>
把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。<br/><br/>
$(findstring &lt;find&gt;,&lt;in&gt; )<br/><br/>
名称：查找字符串函数——findstring。<br/>
功能：在字串&lt;in&gt;中查找&lt;find&gt;字串。<br/>
返回：如果找到，那么返回&lt;find&gt;，否则返回空字符串。<br/>
示例：<br/><br/>
$(findstring a,a b c)<br/>
$(findstring a,b c)<br/><br/>
第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）<br/><br/>
$(filter &lt;pattern...&gt;,&lt;text&gt; )<br/><br/>
名称：过滤函数——filter。<br/>
功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，保留符合模式&lt;pattern&gt;的单词。可以有多个模式。<br/>
返回：返回符合模式&lt;pattern&gt;的字串。<br/>
示例：<br/><br/>
sources := foo.c bar.c baz.s ugh.h<br/>
foo: $(sources)<br/>
cc $(filter %.c %.s,$(sources)) -o foo<br/><br/>
$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。<br/><br/>
$(filter-out &lt;pattern...&gt;,&lt;text&gt; )<br/><br/>
名称：反过滤函数——filter-out。<br/>
功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，去除符合模式&lt;pattern&gt;的单词。可以有多个模式。<br/>
返回：返回不符合模式&lt;pattern&gt;的字串。<br/>
示例：<br/><br/>
objects=main1.o foo.o main2.o bar.o<br/>
mains=main1.o main2.o<br/><br/>
$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。<br/><br/>
$(sort &lt;list&gt; )<br/><br/>
名称：排序函数——sort。<br/>
功能：给字符串&lt;list&gt;中的单词排序（升序）。<br/>
返回：返回排序后的字符串。<br/>
示例：$(sort foo bar lose)返回“bar foo lose” 。<br/>
备注：sort函数会去掉&lt;list&gt;中相同的单词。<br/><br/>
$(word &lt;n&gt;,&lt;text&gt; )<br/><br/>
名称：取单词函数——word。<br/>
功能：取字符串&lt;text&gt;中第&lt;n&gt;个单词。（从一开始）<br/>
返回：返回字符串&lt;text&gt;中第&lt;n&gt;个单词。如果&lt;n&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。<br/>
示例：$(word 2, foo bar baz)返回值是“bar”。<br/><br/>
$(wordlist &lt;s&gt;,&lt;e&gt;,&lt;text&gt; )<br/><br/>
名称：取单词串函数——wordlist。<br/>
功能：从字符串&lt;text&gt;中取从&lt;s&gt;开始到&lt;e&gt;的单词串。&lt;s&gt;和&lt;e&gt;是一个数字。<br/>
返 回：返回字符串&lt;text&gt;中从&lt;s&gt;到&lt;e&gt;的单词字串。如果&lt;s&gt;比&lt;text&gt;中的 单词数要大，那么返回空字符串。如果&lt;e&gt;大于&lt;text&gt;的单词数，那么返回从&lt;s&gt;开始， 到&lt;text&gt;结束的单词串。<br/>
示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。<br/><br/>
$(words &lt;text&gt; )<br/><br/>
名称：单词个数统计函数——words。<br/>
功能：统计&lt;text&gt;中字符串中的单词个数。<br/>
返回：返回&lt;text&gt;中的单词数。<br/>
示例：$(words, foo bar baz)返回值是“3”。<br/>
备注：如果我们要取&lt;text&gt;中最后的一个单词，我们可以这样：$(word $(words &lt;text&gt; ),&lt;text&gt; )。<br/><br/>
$(firstword &lt;text&gt; )<br/><br/>
名称：首单词函数——firstword。<br/>
功能：取字符串&lt;text&gt;中的第一个单词。<br/>
返回：返回字符串&lt;text&gt;的第一个单词。<br/>
示例：$(firstword foo bar)返回值是“foo”。<br/>
备注：这个函数可以用word函数来实现：$(word 1,&lt;text&gt; )。<br/><br/>
以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：<br/><br/>
override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))<br/><br/>
如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数。<br/><br/><br/>
三、文件名操作函数<br/><br/>
下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。<br/><br/>
$(dir &lt;names...&gt; )<br/><br/>
名称：取目录函数——dir。<br/>
功能：从文件名序列&lt;names&gt;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。<br/>
返回：返回文件名序列&lt;names&gt;的目录部分。<br/>
示例： $(dir src/foo.c hacks)返回值是“src/ ./”。<br/><br/>
$(notdir &lt;names...&gt; )<br/><br/>
名称：取文件函数——notdir。<br/>
功能：从文件名序列&lt;names&gt;中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。<br/>
返回：返回文件名序列&lt;names&gt;的非目录部分。<br/>
示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。<br/><br/>
$(suffix &lt;names...&gt; )<br/><br/>
名称：取后缀函数——suffix。<br/>
功能：从文件名序列&lt;names&gt;中取出各个文件名的后缀。<br/>
返回：返回文件名序列&lt;names&gt;的后缀序列，如果文件没有后缀，则返回空字串。<br/>
示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。<br/><br/>
$(basename &lt;names...&gt; )<br/><br/>
名称：取前缀函数——basename。<br/>
功能：从文件名序列&lt;names&gt;中取出各个文件名的前缀部分。<br/>
返回：返回文件名序列&lt;names&gt;的前缀序列，如果文件没有前缀，则返回空字串。<br/>
示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar hacks”。<br/><br/>
$(addsuffix &lt;suffix&gt;,&lt;names...&gt; )<br/><br/>
名称：加后缀函数——addsuffix。<br/>
功能：把后缀&lt;suffix&gt;加到&lt;names&gt;中的每个单词后面。<br/>
返回：返回加过后缀的文件名序列。<br/>
示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。<br/><br/>
$(addprefix &lt;prefix&gt;,&lt;names...&gt; )<br/><br/>
名称：加前缀函数——addprefix。<br/>
功能：把前缀&lt;prefix&gt;加到&lt;names&gt;中的每个单词后面。<br/>
返回：返回加过前缀的文件名序列。<br/>
示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。<br/><br/>
$(join &lt;list1&gt;,&lt;list2&gt; )<br/><br/>
名称：连接函数——join。<br/>
功 能：把&lt;list2&gt;中的单词对应地加到&lt;list1&gt;的单词后面。如果&lt;list1&gt;的单词个数要 比&lt;list2&gt;的多，那么，&lt;list1&gt;中的多出来的单词将保持原样。如果&lt;list2&gt;的单词个数要 比&lt;list1&gt;多，那么，&lt;list2&gt;多出来的单词将被复制到&lt;list2&gt;中。<br/>
返回：返回连接过后的字符串。<br/>
示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。<br/><br/><br/><br/>
四、foreach 函数<br/><br/><br/>
foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：<br/><br/><br/><br/>
$(foreach &lt;var&gt;,&lt;list&gt;,&lt;text&gt; )<br/><br/><br/><br/>
这 个函数的意思是，把参数&lt;list&gt;中的单词逐一取出放到参数&lt;var&gt;所指定的变量中，然后再执行&lt;text&gt;所 包含的表达式。每一次&lt;text&gt;会返回一个字符串，循环过程中，&lt;text&gt;的所返回的每个字符串会以空格分隔，最后当整个循 环结束时，&lt;text&gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。<br/><br/><br/><br/>
所以，&lt;var&gt;最好是一个变量名，&lt;list&gt;可以是一个表达式，而&lt;text&gt;中一般会使用&lt;var&gt;这个参数来依次枚举&lt;list&gt;中的单词。举个例子：<br/><br/><br/><br/>
names := a b c d<br/><br/>
files := $(foreach n,$(names),$(n).o)<br/><br/><br/><br/>
上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(files)的值是“a.o b.o c.o d.o”。<br/><br/><br/><br/>
注意，foreach中的&lt;var&gt;参数是一个临时的局部变量，foreach函数执行完后，参数&lt;var&gt;的变量将不在作用，其作用域只在foreach函数当中。<br/><br/><br/><br/><br/><br/>
五、if 函数<br/><br/><br/>
if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：<br/><br/><br/><br/>
$(if &lt;condition&gt;,&lt;then-part&gt; )<br/><br/><br/><br/>
或是<br/><br/><br/><br/>
$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt; )<br/><br/><br/><br/>
可 见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。&lt;condition&gt;参数是if的表达式， 如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，&lt;then-part&gt;会被计算，否则&lt;else-part&gt; 会被计算。<br/><br/><br/><br/>
而if函数的返回值是，如果&lt;condition&gt;为真（非空字符串），那个&lt;then- part&gt;会是整个函数的返回值，如果&lt;condition&gt;为假（空字符串），那么&lt;else-part&gt;会是整个函数 的返回值，此时如果&lt;else-part&gt;没有被定义，那么，整个函数返回空字串。<br/><br/><br/><br/>
所以，&lt;then-part&gt;和&lt;else-part&gt;只会有一个被计算。<br/><br/><br/><br/><br/><br/>
六、call函数<br/><br/><br/>
call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：<br/><br/><br/><br/>
$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)<br/><br/><br/><br/>
当 make执行这个函数时，&lt;expression&gt;参数中的变量，如$(1)，$(2)，$(3)等，会被参 数&lt;parm1&gt;，&lt;parm2&gt;，&lt;parm3&gt;依次取代。而&lt;expression&gt;的返回值就是 call函数的返回值。例如：<br/><br/>
reverse = $(1) $(2)<br/><br/>
foo = $(call reverse,a,b)<br/><br/><br/><br/>
那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：<br/><br/><br/><br/>
reverse = $(2) $(1)<br/><br/>
foo = $(call reverse,a,b)<br/><br/><br/><br/>
此时的foo的值就是“b a”。<br/><br/><br/><br/><br/><br/>
七、origin函数<br/>
origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：<br/><br/><br/><br/>
$(origin &lt;variable&gt; )<br/><br/><br/><br/>
注意，&lt;variable&gt;是变量的名字，不应该是引用。所以你最好不要在&lt;variable&gt;中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函数的返回值:<br/><br/><br/><br/>
“undefined”<br/><br/>
如果&lt;variable&gt;从来没有定义过，origin函数返回这个值“undefined”。<br/><br/><br/><br/>
“default”<br/><br/>
如果&lt;variable&gt;是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。<br/><br/><br/><br/>
“environment”<br/><br/>
如果&lt;variable&gt;是一个环境变量，并且当<b style="background-color: rgb(160, 255, 255);">Makefile</b>被执行时，“-e”参数没有被打开。<br/><br/><br/><br/>
“file”<br/><br/>
如果&lt;variable&gt;这个变量被定义在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中。<br/><br/><br/><br/>
“command line”<br/><br/>
如果&lt;variable&gt;这个变量是被命令行定义的。<br/><br/><br/><br/>
“override”<br/><br/>
如果&lt;variable&gt;是被override指示符重新定义的。<br/><br/><br/><br/>
“automatic”<br/><br/>
如果&lt;variable&gt;是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。<br/><br/><br/><br/>
这些信息对于我们编写<b style="background-color: rgb(160, 255, 255);">Makefile</b>是非常有用的，例如，假设我们有一个<b style="background-color: rgb(160, 255, 255);">Makefile</b>其 包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一个环境变量“bletch”，此时，我们 想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是，在我们的<b style="background-color: rgb(160, 255, 255);">Makefile</b>中，我们可以这样写：<br/><br/><br/><br/>
ifdef bletch<br/><br/>
ifeq &quot;$(origin bletch)&quot; &quot;environment&quot;<br/><br/>
bletch = barf, gag, etc.<br/><br/>
endif<br/><br/>
endif<br/><br/><br/><br/>
当 然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样 的效果，可是override过于粗暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。<br/><br/><br/><br/><br/><br/>
八、shell函数<br/><br/><br/>
shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命 令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：<br/><br/><br/><br/>
contents := $(shell cat foo)<br/><br/><br/><br/>
files := $(shell echo *.c)<br/><br/><br/><br/>
注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的<b style="background-color: rgb(160, 255, 255);">Makefile</b>中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是<b style="background-color: rgb(160, 255, 255);">Makefile</b>的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。<br/><br/><br/><br/><br/><br/>
九、控制make的函数<br/><br/><br/>
make提供了一些函数来控制make的运行。通常，你需要检测一些运行<b style="background-color: rgb(160, 255, 255);">Makefile</b>时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。<br/><br/><br/><br/>
$(error &lt;text ...&gt; )<br/><br/><br/><br/>
产生一个致命的错误，&lt;text ...&gt;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：<br/><br/><br/><br/>
示例一：<br/><br/>
ifdef ERROR_001<br/><br/>
$(error error is $(ERROR_001))<br/><br/>
endif<br/><br/><br/><br/>
示例二：<br/><br/>
ERR = $(error found an error!)<br/><br/>
.PHONY: err<br/><br/>
err: ; $(ERR)<br/><br/><br/><br/>
示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。<br/><br/><br/><br/>
$(warning &lt;text ...&gt; )<br/><br/><br/><br/>
这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。<br/><br/>
make 的运行<br/>
——————<br/><br/>
一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的<b style="background-color: rgb(160, 255, 255);">makefile</b>来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。<br/><br/>
一、make的退出码<br/><br/>
make命令执行后有三个退出码：<br/><br/>
0 —— 表示成功执行。<br/>
1 —— 如果make运行时出现任何错误，其返回1。<br/>
2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。<br/><br/>
Make的相关参数我们会在后续章节中讲述。<br/><br/><br/>
二、指定<b style="background-color: rgb(160, 255, 255);">Makefile</b><br/><br/>
前面我们说过，GNU make找寻默认的<b style="background-color: rgb(160, 255, 255);">Makefile</b>的规则是在当前目录下依次找三个文件——“GNUmakefile”、“<b style="background-color: rgb(160, 255, 255);">makefile</b>”和“<b style="background-color: rgb(160, 255, 255);">Makefile</b>”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。<br/><br/>
当前，我们也可以给make命令指定一个特殊名字的<b style="background-color: rgb(160, 255, 255);">Makefile</b>。要达到这个功能，我们要使用make的“-f”或是“--file”参数（“--<b style="background-color: rgb(160, 255, 255);">makefile</b>”参数也行）。例如，我们有个<b style="background-color: rgb(160, 255, 255);">makefile</b>的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：<br/><br/>
make –f hchen.mk<br/><br/>
如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的<b style="background-color: rgb(160, 255, 255);">makefile</b>将会被连在一起传递给make执行。<br/><br/><br/>
三、指定目标<br/><br/>
一般来说，make的最终目标是<b style="background-color: rgb(160, 255, 255);">makefile</b>中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的<b style="background-color: rgb(160, 255, 255);">makefile</b>中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）<br/><br/>
任何在<b style="background-color: rgb(160, 255, 255);">makefile</b>中 的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明 确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。<br/><br/>
有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：<br/><br/>
sources = foo.c bar.c<br/>
ifneq ( $(MAKECMDGOALS),clean)<br/>
include $(sources:.c=.d)<br/>
endif<br/><br/>
基于上面的这个例子，只要我们输入的命令不是“make clean”，那么<b style="background-color: rgb(160, 255, 255);">makefile</b>会自动包含“foo.d”和“bar.d”这两个<b style="background-color: rgb(160, 255, 255);">makefile</b>。<br/><br/>
使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：<br/><br/>
.PHONY: all<br/>
all: prog1 prog2 prog3 prog4<br/><br/>
从这个例子中，我们可以看到，这个<b style="background-color: rgb(160, 255, 255);">makefile</b>中 有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。<br/><br/>
即然make可以指定所有<b style="background-color: rgb(160, 255, 255);">makefile</b>中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的<b style="background-color: rgb(160, 255, 255);">makefile</b>根据指定的不同的目标来完成不同的事。在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其<b style="background-color: rgb(160, 255, 255);">makefile</b>都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的<b style="background-color: rgb(160, 255, 255);">makefile</b>中的目标。<br/><br/>
“all”<br/>
这个伪目标是所有目标的目标，其功能一般是编译所有的目标。<br/>
“clean”<br/>
这个伪目标功能是删除所有被make创建的文件。<br/>
“install”<br/>
这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。<br/>
“print”<br/>
这个伪目标的功能是例出改变过的源文件。<br/>
“tar”<br/>
这个伪目标功能是把源程序打包备份。也就是一个tar文件。<br/>
“dist”<br/>
这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。<br/>
“TAGS”<br/>
这个伪目标功能是更新所有的目标，以备完整地重编译使用。<br/>
“check”和“test”<br/>
这两个伪目标一般用来测试<b style="background-color: rgb(160, 255, 255);">makefile</b>的流程。<br/><br/>
当然一个项目的<b style="background-color: rgb(160, 255, 255);">makefile</b>中 也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些 功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而 且如果你的<b style="background-color: rgb(160, 255, 255);">makefile</b>中有这些功能，一是很实用，二是可以显得你的<b style="background-color: rgb(160, 255, 255);">makefile</b>很专业（不是那种初学者的作品）。<br/><br/><br/>
四、检查规则<br/><br/>
有时候，我们不想让我们的<b style="background-color: rgb(160, 255, 255);">makefile</b>中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：<br/><br/>
“-n”<br/>
“--just-print”<br/>
“--dry-run”<br/>
“--recon”<br/>
不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试<b style="background-color: rgb(160, 255, 255);">makefile</b>很有用处。<br/><br/>
“-t”<br/>
“--touch”<br/>
这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。<br/><br/>
“-q”<br/>
“--question”<br/>
这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。<br/><br/>
“-W &lt;file&gt;”<br/>
“--what-if=&lt;file&gt;”<br/>
“--assume-new=&lt;file&gt;”<br/>
“--new-file=&lt;file&gt;”<br/>
这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。<br/><br/>
另外一个很有意思的用法是结合“-p”和“-v”来输出<b style="background-color: rgb(160, 255, 255);">makefile</b>被执行时的信息（这个将在后面讲述）。<br/><br/><br/>
五、make的参数<br/><br/>
下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。<br/><br/>
“-b”<br/>
“-m”<br/>
这两个参数的作用是忽略和其它版本make的兼容性。<br/><br/>
“-B”<br/>
“--always-make”<br/>
认为所有的目标都需要更新（重编译）。<br/><br/>
“-C &lt;dir&gt;”<br/>
“--directory=&lt;dir&gt;”<br/>
指定读取<b style="background-color: rgb(160, 255, 255);">makefile</b>的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。<br/><br/>
“—debug[=&lt;options&gt;]”<br/>
输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;的取值：<br/>
a —— 也就是all，输出所有的调试信息。（会非常的多）<br/>
b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。<br/>
v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个<b style="background-color: rgb(160, 255, 255);">makefile</b>被解析，不需要被重编译的依赖文件（或是依赖目标）等。<br/>
i —— 也就是implicit，输出所以的隐含规则。<br/>
j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。<br/>
m —— 也就是<b style="background-color: rgb(160, 255, 255);">makefile</b>，输出make读取<b style="background-color: rgb(160, 255, 255);">makefile</b>，更新<b style="background-color: rgb(160, 255, 255);">makefile</b>，执行<b style="background-color: rgb(160, 255, 255);">makefile</b>的信息。<br/><br/>
“-d”<br/>
相当于“--debug=a”。<br/><br/>
“-e”<br/>
“--environment-overrides”<br/>
指明环境变量的值覆盖<b style="background-color: rgb(160, 255, 255);">makefile</b>中定义的变量的值。<br/><br/>
“-f=&lt;file&gt;”<br/>
“--file=&lt;file&gt;”<br/>
“--<b style="background-color: rgb(160, 255, 255);">makefile</b>=&lt;file&gt;”<br/>
指定需要执行的<b style="background-color: rgb(160, 255, 255);">makefile</b>。<br/><br/>
“-h”<br/>
“--help”<br/>
显示帮助信息。<br/><br/>
“-i”<br/>
“--ignore-errors”<br/>
在执行时忽略所有的错误。<br/><br/>
“-I &lt;dir&gt;”<br/>
“--include-dir=&lt;dir&gt;”<br/>
指定一个被包含<b style="background-color: rgb(160, 255, 255);">makefile</b>的搜索目标。可以使用多个“-I”参数来指定多个目录。<br/><br/>
“-j [&lt;jobsnum&gt;]”<br/>
“--jobs[=&lt;jobsnum&gt;]”<br/>
指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）<br/><br/>
“-k”<br/>
“--keep-going”<br/>
出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。<br/><br/>
“-l &lt;load&gt;”<br/>
“--load-average[=&lt;load]”<br/>
“—max-load[=&lt;load&gt;]”<br/>
指定make运行命令的负载。<br/><br/>
“-n”<br/>
“--just-print”<br/>
“--dry-run”<br/>
“--recon”<br/>
仅输出执行过程中的命令序列，但并不执行。<br/><br/>
“-o &lt;file&gt;”<br/>
“--old-file=&lt;file&gt;”<br/>
“--assume-old=&lt;file&gt;”<br/>
不重新生成的指定的&lt;file&gt;，即使这个目标的依赖文件新于它。<br/><br/>
“-p”<br/>
“--print-data-base”<br/>
输出<b style="background-color: rgb(160, 255, 255);">makefile</b>中的所有数据，包括所有的规则和变量。这个参数会让一个简单的<b style="background-color: rgb(160, 255, 255);">makefile</b>都会输出一堆信息。如果你只是想输出信息而不想执行<b style="background-color: rgb(160, 255, 255);">makefile</b>，你可以使用“make -qp”命令。如果你想查看执行<b style="background-color: rgb(160, 255, 255);">makefile</b>前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的<b style="background-color: rgb(160, 255, 255);">makefile</b>文件的文件名和行号，所以，用这个参数来调试你的<b style="background-color: rgb(160, 255, 255);">makefile</b>会是很有用的，特别是当你的环境变量很复杂的时候。<br/><br/>
“-q”<br/>
“--question”<br/>
不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。<br/><br/>
“-r”<br/>
“--no-builtin-rules”<br/>
禁止make使用任何隐含规则。<br/><br/>
“-R”<br/>
“--no-builtin-variabes”<br/>
禁止make使用任何作用于变量上的隐含规则。<br/><br/>
“-s”<br/>
“--silent”<br/>
“--quiet”<br/>
在命令运行时不输出命令的输出。<br/><br/>
“-S”<br/>
“--no-keep-going”<br/>
“--stop”<br/>
取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。<br/><br/>
“-t”<br/>
“--touch”<br/>
相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。<br/><br/>
“-v”<br/>
“--version”<br/>
输出make程序的版本、版权等关于make的信息。<br/><br/>
“-w”<br/>
“--print-directory”<br/>
输出运行<b style="background-color: rgb(160, 255, 255);">makefile</b>之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。<br/><br/>
“--no-print-directory”<br/>
禁止“-w”选项。<br/><br/>
“-W &lt;file&gt;”<br/>
“--what-if=&lt;file&gt;”<br/>
“--new-file=&lt;file&gt;”<br/>
“--assume-file=&lt;file&gt;”<br/>
假定目标&lt;file&gt;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;的修改时间为当前时间。<br/><br/>
“--warn-undefined-variables”<br/>
只要make发现有未定义的变量，那么就输出警告信息。</span></font></span></font></p><p><font face="verdana, arial, helvetica" size="2"><font face="verdana, arial, helvetica" size="2"><span style="FONT-SIZE: 12px"><font face="verdana, arial, helvetica" size="2"><span style="FONT-SIZE: 12px">隐含规则<br/>
————<br/><br/>
在我们使用<b style="background-color: rgb(160, 255, 255);">Makefile</b>时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o]文件，Windows下是[.obj]文件）。本章讲述的就是一些在<b style="background-color: rgb(160, 255, 255);">Makefile</b>中的“隐含的”，早先约定了的，不需要我们再写出来的规则。<br/><br/>
“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的<b style="background-color: rgb(160, 255, 255);">Makefile</b>中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。<br/><br/>
“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。<br/><br/>
我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保证我们<b style="background-color: rgb(160, 255, 255);">Makefile</b>的兼容性。<br/>
我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行<b style="background-color: rgb(160, 255, 255);">Makefile</b>时出现一些我们觉得莫名其妙的东西。当然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。<br/><br/><br/>
一、使用隐含规则<br/><br/>
如 果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可 以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个<b style="background-color: rgb(160, 255, 255);">Makefile</b>：<br/><br/>
foo : foo.o bar.o<br/>
cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)<br/><br/>
我们可以注意到，这个<b style="background-color: rgb(160, 255, 255);">Makefile</b>中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。<br/><br/>
make 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：<br/><br/>
foo.o : foo.c<br/>
cc –c foo.c $(CFLAGS)<br/>
bar.o : bar.c<br/>
cc –c bar.c $(CFLAGS)<br/><br/>
因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。<br/><br/>
当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。<br/><br/>
还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：<br/><br/>
foo.o : foo.p<br/><br/>
依 赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。<br/><br/><br/>
二、隐含规则一览<br/><br/>
这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。<br/><br/>
当 然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表” （也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。<br/><br/>
还是先来看一看常用的隐含规则吧。<br/><br/>
1、编译C程序的隐含规则。<br/>
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”<br/><br/>
2、编译C++程序的隐含规则。<br/>
“&lt;n&gt;.o” 的目标的依赖目标会自动推导为“&lt;n&gt;.cc”或是“&lt;n&gt;.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）<br/><br/>
3、编译Pascal程序的隐含规则。<br/>
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。<br/><br/>
4、编译Fortran/Ratfor程序的隐含规则。<br/>
“&lt;n&gt;.o”的目标的依赖目标会自动推导为“&lt;n&gt;.r”或“&lt;n&gt;.F”或“&lt;n&gt;.f”，并且其生成命令是:<br/>
“.f” “$(FC) –c $(FFLAGS)”<br/>
“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”<br/>
“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”<br/><br/>
5、预处理Fortran/Ratfor程序的隐含规则。<br/>
“&lt;n&gt;.f”的目标的依赖目标会自动推导为“&lt;n&gt;.r”或“&lt;n&gt;.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：<br/>
“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”<br/>
“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”<br/><br/>
6、编译Modula-2程序的隐含规则。<br/>
“&lt;n&gt;.sym” 的目标的依赖目标会自动推导为“&lt;n&gt;.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;” 的目标的依赖目标会自动推导为“&lt;n&gt;.mod”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。<br/><br/>
7、汇编和汇编预处理的隐含规则。<br/>
“&lt;n&gt;.o” 的目标的依赖目标会自动推导为“&lt;n&gt;.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“&lt;n&gt;.s” 的目标的依赖目标会自动推导为“&lt;n&gt;.S”，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。<br/><br/>
8、链接Object文件的隐含规则。<br/>
“&lt;n&gt;” 目标依赖于“&lt;n&gt;.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) &lt;n&gt;.o $(LOADLIBES) $(LDLIBS)”。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：<br/><br/>
x : y.o z.o<br/><br/>
并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：<br/><br/>
cc -c x.c -o x.o<br/>
cc -c y.c -o y.o<br/>
cc -c z.c -o z.o<br/>
cc x.o y.o z.o -o x<br/>
rm -f x.o<br/>
rm -f y.o<br/>
rm -f z.o<br/><br/>
如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。<br/><br/>
9、Yacc C程序时的隐含规则。<br/>
“&lt;n&gt;.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）<br/><br/>
10、Lex C程序时的隐含规则。<br/>
“&lt;n&gt;.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）<br/><br/>
11、Lex Ratfor程序时的隐含规则。<br/>
“&lt;n&gt;.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。<br/><br/>
12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。<br/>
“&lt;n&gt;.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“&lt;n&gt;.y”和“&lt;n&gt;.l”也是同样的规则。<br/><br/><br/>
三、隐含规则使用的变量<br/><br/>
在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的<b style="background-color: rgb(160, 255, 255);">makefile</b>中 改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则 起作用。当然，你也可以利用make的“-R”或“--no–builtin-variables”参数来取消你所定义的变量对隐含规则的作用。<br/><br/>
例 如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。<br/><br/>
我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：<br/><br/>
1、关于命令的变量。<br/><br/>
AR<br/>
函数库打包程序。默认命令是“ar”。<br/>
AS<br/>
汇编语言编译程序。默认命令是“as”。<br/>
CC<br/>
C语言编译程序。默认命令是“cc”。<br/>
CXX<br/>
C++语言编译程序。默认命令是“g++”。<br/>
CO<br/>
从 RCS文件中扩展文件程序。默认命令是“co”。<br/>
CPP<br/>
C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。<br/>
FC<br/>
Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。<br/>
GET<br/>
从SCCS文件中扩展文件的程序。默认命令是“get”。<br/>
LEX<br/>
Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。<br/>
PC<br/>
Pascal语言编译程序。默认命令是“pc”。<br/>
YACC<br/>
Yacc文法分析器（针对于C程序）。默认命令是“yacc”。<br/>
YACCR<br/>
Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。<br/>
MAKEINFO<br/>
转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。<br/>
TEX<br/>
从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。<br/>
TEXI2DVI<br/>
从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。<br/>
WEAVE<br/>
转换Web到TeX的程序。默认命令是“weave”。<br/>
CWEAVE<br/>
转换C Web 到 TeX的程序。默认命令是“cweave”。<br/>
TANGLE<br/>
转换Web到Pascal语言的程序。默认命令是“tangle”。<br/>
CTANGLE<br/>
转换C Web 到 C。默认命令是“ctangle”。<br/>
RM<br/>
删除文件命令。默认命令是“rm –f”。<br/><br/>
2、关于命令参数的变量<br/><br/>
下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。<br/><br/>
ARFLAGS<br/>
函数库打包程序AR命令的参数。默认值是“rv”。<br/>
ASFLAGS<br/>
汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。<br/>
CFLAGS<br/>
C语言编译器参数。<br/>
CXXFLAGS<br/>
C++语言编译器参数。<br/>
COFLAGS<br/>
RCS命令参数。<br/>
CPPFLAGS<br/>
C预处理器参数。（ C 和 Fortran 编译器也会用到）。<br/>
FFLAGS<br/>
Fortran语言编译器参数。<br/>
GFLAGS<br/>
SCCS “get”程序参数。<br/>
LDFLAGS<br/>
链接器参数。（如：“ld”）<br/>
LFLAGS<br/>
Lex文法分析器参数。<br/>
PFLAGS<br/>
Pascal语言编译器参数。<br/>
RFLAGS<br/>
Ratfor 程序的Fortran 编译器参数。<br/>
YFLAGS<br/>
Yacc文法分析器参数。<br/><br/><br/>
四、隐含规则链<br/><br/>
有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。<br/><br/>
在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。<br/><br/>
我 们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的 隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的<b style="background-color: rgb(160, 255, 255);">makefile</b>发疯了？<br/><br/>
在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。<br/><br/>
通常，一个被<b style="background-color: rgb(160, 255, 255);">makefile</b>指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）<br/><br/>
你 也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。<br/><br/>
在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。<br/><br/>
Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然 后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。<br/><br/><br/><br/>
五、定义模式规则<br/><br/>
你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有&quot;%&quot;字符。&quot;%&quot;的意思是表示一个或多个任意字符。在依赖目标中同样可以使用&quot;%&quot;，只是依赖目标中的&quot;%&quot;的取值，取决于其目标。<br/><br/>
有一点需要注意的是，&quot;%&quot;的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入<b style="background-color: rgb(160, 255, 255);">Makefile</b>时，而模式规则中的&quot;%&quot;则发生在运行时。<br/><br/><br/>
1、模式规则介绍<br/><br/>
模 式规则中，至少在规则的目标定义中要包含&quot;%&quot;，否则，就是一般的规则。目标中的&quot;%&quot;定义表示对文件名的匹配，&quot;%&quot;表示长度任意的非空字符串。例 如：&quot;%.c&quot;表示以&quot;.c&quot;结尾的文件名（文件名的长度至少为3），而&quot;s.%.c&quot;则表示以&quot;s.&quot;开头，&quot;.c&quot;结尾的文件名（文件名的长度至少为 5）。<br/><br/>
如果&quot;%&quot;定义在目标中，那么，目标中的&quot;%&quot;的值决定了依赖目标中的&quot;%&quot;的值，也就是说，目标中的模式的&quot;%&quot;决定了依赖目标中&quot;%&quot;的样子。例如有一个模式规则如下：<br/><br/>
%.o : %.c ; &lt;command ......&gt;<br/><br/>
其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是&quot;a.o b.o&quot;，那么&quot;%c&quot;就是&quot;a.c b.c&quot;。<br/><br/>
一 旦依赖目标中的&quot;%&quot;模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标 可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。<br/><br/><br/>
2、模式规则示例<br/><br/>
下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.<br/><br/>
%.o : %.c<br/>
$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@<br/><br/>
其中，&quot;$@&quot;表示所有的目标的挨个值，&quot;$&lt;&quot;表示了所有依赖目标的挨个值。这些奇怪的变量我们叫&quot;自动化变量&quot;，后面会详细讲述。<br/><br/>
下面的这个例子中有两个目标是模式的：<br/><br/>
%.tab.c %.tab.h: %.y<br/>
bison -d $&lt;<br/><br/>
这 条规则告诉make把所有的[.y]文件都以&quot;bison -d &lt;n&gt;.y&quot;执行，然后生成&quot;&lt;n&gt;.tab.c&quot;和&quot;&lt;n&gt;.tab.h&quot;文件。（其中，&quot;&lt;n&gt;&quot; 表示一个任意字符串）。如果我们的执行程序&quot;foo&quot;依赖于文件&quot;parse.tab.o&quot;和&quot;scan.o&quot;，并且文件&quot;scan.o&quot;依赖于文 件&quot;parse.tab.h&quot;，如果&quot;parse.y&quot;文件被更新了，那么根据上述的规则，&quot;bison -d parse.y&quot;就会被执行一次，于是，&quot;parse.tab.o&quot;和&quot;scan.o&quot;的依赖文件就齐了。（假设，&quot;parse.tab.o&quot; 由&quot;parse.tab.c&quot;生成，和&quot;scan.o&quot;由&quot;scan.c&quot;生成，而&quot;foo&quot;由&quot;parse.tab.o&quot;和&quot;scan.o&quot;链接生成， 而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）<br/><br/><br/>
3、自动化变量<br/><br/>
在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。<br/><br/>
自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。<br/><br/>
下面是所有的自动化变量及其说明：<br/><br/>
$@<br/>
表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，&quot;$@&quot;就是匹配于目标中模式定义的集合。<br/><br/>
$%<br/>
仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是&quot;foo.a(bar.o)&quot;，那么，&quot;$%&quot;就是&quot;bar.o&quot;，&quot;$@&quot;就是&quot;foo.a&quot;。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。<br/><br/>
$&lt;<br/>
依赖目标中的第一个目标名字。如果依赖目标是以模式（即&quot;%&quot;）定义的，那么&quot;$&lt;&quot;将是符合模式的一系列的文件集。注意，其是一个一个取出来的。<br/><br/>
$?<br/>
所有比目标新的依赖目标的集合。以空格分隔。<br/><br/>
$^<br/>
所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。<br/><br/>
$+<br/>
这个变量很像&quot;$^&quot;，也是所有依赖目标的集合。只是它不去除重复的依赖目标。<br/><br/>
$*<br/>
这 个变量表示目标模式中&quot;%&quot;及其之前的部分。如果目标是&quot;dir/a.foo.b&quot;，并且目标的模式是&quot;a.%.b&quot;，那么，&quot;$*&quot;的值就是&quot;dir /a.foo&quot;。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么&quot;$*&quot;也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么&quot;$*&quot;就是除了后缀的那一部分。例如：如果目标是&quot;foo.c&quot;，因为&quot;.c&quot;是make所能识别的后缀名，所以，&quot;$*&quot;的值 就是&quot;foo&quot;。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用&quot;$*&quot;，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不 能识别的，那么&quot;$*&quot;就是空值。<br/><br/>
当你希望只对更新过的依赖文件进行操作时，&quot;$?&quot;在显式规则中很有用，例如，假设有一个函数库文件叫&quot;lib&quot;，其由其它几个object文件更新。那么把object文件打包的比较有效率的<b style="background-color: rgb(160, 255, 255);">Makefile</b>规则是：<br/><br/>
lib : foo.o bar.o lose.o win.o<br/>
ar r lib $?<br/><br/>
在 上述所列出来的自动量变量中。四个变量（$@、$&lt;、$%、$*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取 得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上&quot;D&quot;或&quot;F&quot;字样。这是GNU make中老版本的特性，在新版本中，我们使用函数&quot;dir&quot;或&quot;notdir&quot;就可以做到了。&quot;D&quot;的含义就是Directory，就是目录，&quot;F&quot;的 含义就是File，就是文件。<br/><br/>
下面是对于上面的七个变量分别加上&quot;D&quot;或是&quot;F&quot;的含义：<br/><br/>
$(@D)<br/>
表示&quot;$@&quot;的目录部分（不以斜杠作为结尾），如果&quot;$@&quot;值是&quot;dir/foo.o&quot;，那么&quot;$(@D)&quot;就是&quot;dir&quot;，而如果&quot;$@&quot;中没有包含斜杠的话，其值就是&quot;.&quot;（当前目录）。<br/><br/>
$(@F)<br/>
表示&quot;$@&quot;的文件部分，如果&quot;$@&quot;值是&quot;dir/foo.o&quot;，那么&quot;$(@F)&quot;就是&quot;foo.o&quot;，&quot;$(@F)&quot;相当于函数&quot;$(notdir $@)&quot;。<br/><br/>
&quot;$(*D)&quot;<br/>
&quot;$(*F)&quot;<br/>
和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，&quot;$(*D)&quot;返回&quot;dir&quot;，而&quot;$(*F)&quot;返回&quot;foo&quot;<br/><br/>
&quot;$(%D)&quot;<br/>
&quot;$(%F)&quot;<br/>
分别表示了函数包文件成员的目录部分和文件部分。这对于形同&quot;archive(member)&quot;形式的目标中的&quot;member&quot;中包含了不同的目录很有用。<br/><br/>
&quot;$(&lt;D)&quot;<br/>
&quot;$(&lt;F)&quot;<br/>
分别表示依赖文件的目录部分和文件部分。<br/><br/>
&quot;$(^D)&quot;<br/>
&quot;$(^F)&quot;<br/>
分别表示所有依赖文件的目录部分和文件部分。（无相同的）<br/><br/>
&quot;$(+D)&quot;<br/>
&quot;$(+F)&quot;<br/>
分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）<br/><br/>
&quot;$(?D)&quot;<br/>
&quot;$(?F)&quot;<br/>
分别表示被更新的依赖文件的目录部分和文件部分。<br/><br/>
最后想提醒一下的是，对于&quot;$&lt;&quot;，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，&quot;$(&lt; )&quot;就要比&quot;$&lt;&quot;要好一些。<br/><br/>
还得要注意的是，这些变量只使用在规则的命令中，而且一般都是&quot;显式规则&quot;和&quot;静态模式规则&quot;（参见前面&quot;书写规则&quot;一章）。其在隐含规则中并没有意义。<br/><br/>
4、模式的匹配<br/><br/>
一 般来说，一个目标的模式有一个有前缀或是后缀的&quot;%&quot;，或是没有前后缀，直接就是一个&quot;%&quot;。因为&quot;%&quot;代表一个或多个字符，所以在定义好了的模式中，我 们把&quot;%&quot;所匹配的内容叫做&quot;茎&quot;，例如&quot;%.c&quot;所匹配的文件&quot;test.c&quot;中&quot;test&quot;就是&quot;茎&quot;。因为在目标和依赖目标中同时有&quot;%&quot;时，依赖 目标的&quot;茎&quot;会传给目标，当做目标中的&quot;茎&quot;。<br/><br/>
当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分 会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行&quot;茎&quot;的传递时，我们需要知道这个步骤。例如有一个模式&quot;e%t&quot;，文件&quot;src/eat&quot; 匹配于该模式，于是&quot;src/a&quot;就是其&quot;茎&quot;，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式&quot;c%r&quot;，那么，目标就 是&quot;src/car&quot;。（&quot;茎&quot;被传递）<br/><br/><br/>
5、重载内建隐含规则<br/><br/>
你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：<br/><br/>
%.o : %.c<br/>
$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)<br/><br/>
你可以取消内建的隐含规则，只要不在后面写命令就行。如：<br/><br/>
%.o : %.s<br/><br/>
同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。<br/><br/><br/>
六、老式风格的&quot;后缀规则&quot;<br/><br/>
后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的<b style="background-color: rgb(160, 255, 255);">Makefile</b>兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：&quot;双后缀&quot;和&quot;单后缀&quot;。<br/><br/>
双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如&quot;.c.o&quot;相当于&quot;%o : %c&quot;。单后缀规则只定义一个后缀，也就是源文件的后缀。如&quot;.c&quot;相当于&quot;% : %.c&quot;。<br/><br/>
后 缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认 识，那就是双后缀规则。例如：&quot;.c&quot;和&quot;.o&quot;都是make所知道。因而，如果你定义了一个规则是&quot;.c.o&quot;那么其就是双后缀规则，意义就是&quot;.c&quot; 是源文件的后缀，&quot;.o&quot;是目标文件的后缀。如下示例：<br/><br/>
.c.o:<br/>
$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;<br/><br/>
后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：<br/><br/>
.c.o: foo.h<br/>
$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;<br/><br/>
这个例子，就是说，文件&quot;.c.o&quot;依赖于文件&quot;foo.h&quot;，而不是我们想要的这样：<br/><br/>
%.o: %.c foo.h<br/>
$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;<br/><br/>
后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。<br/><br/>
而要让make知道一些特定的后缀，我们可以使用伪目标&quot;.SUFFIXES&quot;来定义或是删除，如：<br/><br/>
.SUFFIXES: .hack .win<br/><br/>
把后缀.hack和.win加入后缀列表中的末尾。<br/><br/>
.SUFFIXES: # 删除默认的后缀<br/>
.SUFFIXES: .c .o .h # 定义自己的后缀<br/><br/>
先清楚默认后缀，后定义自己的后缀列表。<br/><br/>
make的参数&quot;-r&quot;或&quot;-no-builtin-rules&quot;也会使用得默认的后缀列表为空。而变量&quot;SUFFIXE&quot;被用来定义默认的后缀列表，你可以用&quot;.SUFFIXES&quot;来改变后缀列表，但请不要改变变量&quot;SUFFIXE&quot;的值。<br/><br/><br/>
七、隐含规则搜索算法<br/><br/>
比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在<b style="background-color: rgb(160, 255, 255);">Makefile</b>被载入内存时，会被转换成模式规则。如果目标是&quot;archive(member)&quot;的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把&quot;member&quot;当作T来搜索。<br/><br/>
1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是&quot;src/foo.o&quot;，那么，D就是&quot;src/&quot;，N就是&quot;foo.o&quot;）<br/><br/>
2、创建所有匹配于T或是N的模式规则列表。<br/><br/>
3、如果在模式规则列表中有匹配所有文件的模式，如&quot;%&quot;，那么从列表中移除其它的模式。<br/><br/>
4、移除列表中没有命令的规则。<br/><br/>
5、对于第一个在列表中的模式规则：<br/>
1）推导其&quot;茎&quot;S，S应该是T或是N匹配于模式中&quot;%&quot;非空的部分。<br/>
2）计算依赖文件。把依赖文件中的&quot;%&quot;都替换成&quot;茎&quot;S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。<br/>
3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫&quot;理当存在&quot;）<br/>
4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该算法。<br/><br/>
6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：<br/>
1）如果规则是终止规则，那就忽略它，继续下一条模式规则。<br/>
2）计算依赖文件。（同第5步）<br/>
3）测试所有的依赖文件是否存在或是理当存在。<br/>
4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。<br/>
5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。<br/><br/>
7、如果没有隐含规则可以使用，查看&quot;.DEFAULT&quot;规则，如果有，采用，把&quot;.DEFAULT&quot;的命令给T使用。<br/><br/>
一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。<br/><br/><br/>
使用make更新函数库文件<br/>
———————————<br/><br/>
函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令&quot;ar&quot;来完成打包工作。<br/><br/>
一、函数库文件的成员<br/><br/>
一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：<br/><br/>
archive(member)<br/><br/>
这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了&quot;ar&quot;命令来服务的。如：<br/><br/>
foolib(hack.o) : hack.o<br/>
ar cr foolib hack.o<br/><br/>
如果要指定多个member，那就以空格分开，如：<br/><br/>
foolib(hack.o kludge.o)<br/><br/>
其等价于：<br/><br/>
foolib(hack.o) foolib(kludge.o)<br/><br/>
你还可以使用Shell的文件通配符来定义，如：<br/><br/>
foolib(*.o)<br/><br/><br/>
二、函数库成员的隐含规则<br/><br/>
当make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是&quot;a(m)&quot;形式的，其会把目标变成&quot;(m)&quot;。于是，如果我们的成员是&quot;%.o&quot;的模式定义，并且如果我们使用&quot;make foo.a(bar.o)&quot;的形式调用<b style="background-color: rgb(160, 255, 255);">Makefile</b>时，隐含规则会去找&quot;bar.o&quot;的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：<br/><br/>
cc -c bar.c -o bar.o<br/>
ar r foo.a bar.o<br/>
rm -f bar.o<br/><br/>
还有一个变量要注意的是&quot;$%&quot;，这是专属函数库文件的自动化变量，有关其说明请参见&quot;自动化变量&quot;一节。<br/><br/><br/>
三、函数库文件的后缀规则<br/><br/>
你可以使用&quot;后缀规则&quot;和&quot;隐含规则&quot;来生成函数库打包文件，如：<br/><br/>
.c.a:<br/>
$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o<br/>
$(AR) r $@ $*.o<br/>
$(RM) $*.o<br/><br/>
其等效于：<br/><br/>
(%.o) : %.c<br/>
$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $*.o<br/>
$(AR) r $@ $*.o<br/>
$(RM) $*.o<br/><br/><br/>
四、注意事项<br/><br/>
在进行函数库打包文件生成时，请小心使用make的并行机制（&quot;-j&quot;参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。<br/><br/>
但就目前而言，你还是应该不要尽量不要使用&quot;-j&quot;参数。</span></font></span></font></font></p></en-note>]]></content><created>20140416T035159Z</created><updated>20140416T071358Z</updated><note-attributes><source-url>http://cache.baiducontent.com/c?m=9d78d513d99d1af31fa7837e7c49843f4e00db3d6bc3975521dbc90ed5264c40347bfeeb797f4513d3b22d2657f35e5c9dac61342a5d7be4c79d8b4bd9bf942d28833a67305add104c8404f99c00769a7ed147eaaa1ce4baf636&amp;p=882a9146cc9959e509a4c7710f4d&amp;newp=92759a41d5dd0ab319be9b7c500892695c16ed60229ccc54&amp;user=baidu&amp;fm=sc&amp;query=linux+makefile&amp;qid=&amp;p1=1</source-url></note-attributes></note><note><title>/etc/profile:此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.</title><content><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE en-note SYSTEM "http://xml.evernote.com/pub/enml2.dtd">

<en-note style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><font><font color="blue">/etc/profile:</font>此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.<br/>
并从/etc/profile.d目录的配置文件中搜集shell的设置.<br/><font color="blue">/etc/bashrc:</font>为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.<br/><font color="blue">~/<b style="color:black;background-color:#ff9999">.bash_profile</b>:</font>每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该<br/>
文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.<br/><font color="blue">~/.bashrc:</font>该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该<br/>
该文件被读取.<br/><font color="blue">~/.bash_logout:</font>当每次退出系统(退出bash shell)时,执行该文件.&nbsp;<br/><br/>
另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承/etc/profile中的变量,他们是&quot;父子&quot;关系.<br/>
&nbsp;<br/>
~/<b style="background-color: rgb(255, 153, 153);">.bash_profile</b> 是交互式、login 方式进入 bash 运行的<br/>
~/.bashrc 是交互式 non-login 方式进入 bash 运行的<br/>
通常二者设置大致相同，所以通常前者会调用后者。<br/><br/>
设置生效：可以重启生效，也可以使用命令：source<br/></font> <font><font color="blue">alias php=/var/eyouim/pub/php/bin/php<br/></font></font><font>source</font> <font><font color="blue">/etc/profile</font></font></en-note>]]></content><created>20140417T075748Z</created><note-attributes><source-url>http://cache.baiducontent.com/c?m=9f65cb4a8c8507ed4fece7631046893b4c4380143fd3d1027fa3c215cc791e121b33f4bc5378435fc4c2083356f4540cb4ad636f764573f1c099954bdfb090282d892434721e8c4412d918aeca4d26c13d841fb4ef4fe8adf04584afa2838c15098a02127bf0e7fb291765bc78f16426e3d18e49650f43fbb727648f4e705d882230f407a4b4693050&amp;p=8b2a9712948a5fbe13bd9b7e0c1793&amp;newp=882a9544d7911bed13abc7710f5d96231610db2151d1d0142d8ed103d5&amp;user=baidu&amp;fm=sc&amp;query=%2Ebashrc%BA%CD%2Ebash%5Fprofile&amp;qid=&amp;p1=1</source-url></note-attributes></note></en-export>
